#%TITLE% ID2C216.MAC Delay Line Detector
#%NAME% ID2C216.MAC Delay Line Detector
#%DESCRIPTION%
#  This macro implements access to F.Sever's C216 device server.%BR%
#  
#  needs macros: isotime.mac jdo edf_save.mac ID2edf_save.mac
#
#  The frame information has to be prepared in a file. Each line of this
#  file will represent a framepair. Each framepair is made up of seven
#  values.
#  %UL% 
#  %LI%   Number of frames (in fact frame-pairs).
#  %LI%   Dead time (in seconds) 
#  %LI%   Dead output (line output active while in dead)
#  %LI%   Dead pause continue stop (normally always 0 = continue)
#  %LI%   Live time 
#  %LI%   Live output 
#  %LI%   Live pause continue stop (normally always 0 = continue, except for 
#         the last frame, where must put 2 = stop)
# 
# %XUL%
#%EXAMPLE%
#%DL% Typical sequence of macros to use:
#%DT%  dldsetup Tango://id2/c216/1 id2/dc/egy id2/dc/sampledistance id2/dc/detposition %DD%
#  (Setup the dld macros with device server name and other parameters)
#%DT%  dldconfig %DD%
#  (will prompt for all necessary information for a new acquisition cycle)
#%DT%  dldinfo %DD%
#  (will prompt for some information to be put in the header file)
#%DT%  dldstart [int/ext] or dldacq deltaT%DD%
#  (triggers the acquisition)
#%DT%  dldsave%DD%
#  (reads MMI data into file)
#%XDL%
#%HISTORY%
#%DL% 
#%DT% 2000-03-29 PB V3.0.1 %DD%
#                   recuperated from saxs4:~specadm/jmacros/ID2vista.mac 
#	            (last save 2000-03-10)
#%DT% 2000-03-29 PB V3.0.2 %DD%
#                   globals added (see ID2dld.mac V2.300.04):
#                   DLD_I0_MONITOR DLD_I0 DLD_I1_MONITOR DLD_I1
#                   DLD_ANODECOUNTS_MONITOR DLD_ANODECOUNTS
#                   DLD_EXPOSURETIME_MONITOR DLD_EXPOSURETIME
#                   DLD_HMSTARTEPOCH
#                   save ehf header file
#                   ONBEAMLINE, automatically set to 1 in dldsetup
#%DT% 2000-03-29 PB V3.0.3 %DD%
#                   dldscalerassign sets DLD_I0_MONITOR, DLD_I1_MONITOR,
#                   DLD_ANODECOUNTS_MONITOR, DLD_EXPOSURETIME_MONITOR
#%DT% 2000-03-29 PB V3.0.4 %dd% 
#                   assignment of DLD_ANODECOUNTS_MONITOR corrected
#%DT% 2000-03-29 PB V3.0.5 %dd%
#                   dldacq saves data, some debug lines removed
#%DT% 2000-03-29 PB V3.0.6 %dd%
#                   dldscalerzero (default of lst_scaler is 14)
#%DT% 2000-03-30 PB V3.0.7 %dd%
#                   dldacq saves data only when title is given
#%DT% 2000-03-30 PB V3.0.8 %dd%
#                   int(anode_value) shown
#%DT% 2000-03-30 PB V3.0.9 %dd%
#                   DLD_DUMMY_IN
#%DT% 2000-10-25 PB V3.0.10 %dd%
#                   udo ID2edf_save must be called externally 
#%DT% 2001-11-21 PB V3.0.11 %dd%
#                   dld_var_init splitted into dld_var_init1 and dld_var_init2
#%DT% 2002-04-10 PB V3.0.12 %dd%
#                   dldscalersetup for 5 parameters (DLD_SCALER_X)
#%DT% 2003-05-09 PB V3.0.12 %dd%
#                   dldscalerdump returns 5 parameters (DLD_SCALER_X) if
#                   DLD_SCALER_X[i] is != 1
#                   yesno
#%DT% 2006-01-24 PB %dd%
#                   dldscalersetup for 6 parameters (DLD_SCALER_GAIN)
#                   dldscalerdump returns 6 parameters if DLD_SCALER_GAIN[]
#                   exists.
#                   dldscalerdump: id2headerscalerupdate added 
#                   dldscalersetup: id2headervfclistupdate added 
#%DT% 2008-08-20 PB %dd%
#                   Change to C216 by Franc Sever
#                   definition of ws, wsa, wss removed here
#                   is reserved for macros of ID2header.mac
#                   use dldwatchscalers,
#                       dldscalerassignshow;dldscalerlist and
#                       dldscalersetupshow 
#                   instead
#%DT% 2008-08-21 PB %dd%
#                   additional macros:  dld_isrunning(), 
#                   dld_frames(), dld_scalers(), dld_scalerread()
#%DT% 2008-08-21 PB %dd% id2ccdclearvista(DLD_DEV) -> dld_clear()
#%DT% 2008-08-21 PB %dd% additional macro: dld_scalerconfig()
#%DT% 2010-01-28 PB 1.9  %dd% user_cleanup2: _dld_cleanup used but defined 
#                        as dld_cleanup. Now defined as _dld_cleanup
#                        DLD_VERSION -> C216_VERSION, dldversion->c216version
#%DT% 2010-05-07 PB 1.11  %dd% {} in comments equilibrated 
#%DT% 2010-05-21 PB 1.12  %dd% dldscatomem: Returns error, when DLD_GRP3 is not
#                              always created => DLD_GRP3_ON defined to check
#                              whether it exists
#%XDL%
#%END%
##

global C216_VERSION 
C216_VERSION="ID02 $Revision: 1.13 $ / $Date: 2010/05/21 13:55:27 $ V3.0.12 PB/VR/FS/TN/AS BRICOSOFT"
#---------------------- DldVersion (internal macro) -------------
##
#  DldVersion 
##
#%IU%
#%MDESC%
#  Shows version of this macro file
#
def c216version '{
  print (sprintf("C216Version %s\n",C216_VERSION));
}'

#---------------------- DldVarInit (internal macro function) -------------
##
#  DldVarInit 
##
#%IU%
#%MDESC%
#  Declares global variables and initialise some of them 
#  dld_var_init2() declares global variables that are not used for ccd
#  
#
def dld_var_init() '{dld_var_init1(); dld_var_init2()}'

def dld_var_init2() '{

  # start unix date+time of the acquisition (corresponds to
  # start date+time for the first iterations if there are more
  # than one iterations over scalers).
  # N.B. The way dldstart macro is written (since _doinoldversion = 0)
  #      the DLD_STARTTIME has meaningfull value only for internal start.
  #      It is DLD_STARTTIME that is put in the header file (the file
  #      which contains scalers data)
  global DLD_STARTTIME # put in header file
  global DLD_HMSTARTTIME
  # N.B. Must keep next one, since used by edf_save_id02!!!
  #      (in macro dldstart it is set only in the case of 
  #       internal start!!!)
  global DLD_HMSTARTEPOCH
 
  # separator word in header file
  global DLD_SEPARATOR
  # small value, Planck constant * speed of light
  global DLD_EPS DLD_HC

  # there is GUI_RUN used, but I do not know where is defined.
  #
  # info used in header
  global DLD_DEFAULT_TITLE DLD_TITLE DLD_EXPERIMENTINFO
  #
  global DLD_CENTER_1 DLD_CENTER_2 DLD_PIXSIZE_1 DLD_PIXSIZE_2
  #
  global DLD_DUMMY_IN
  #
  global DLD_STATIONINFO DLD_PROPOSALINFO
  #
  global DLD_DETECTORINFO DLD_MACHINEINFO DLD_OPTICSINFO
  #
  global DLD_WAVELENGTH DLD_SAMPLEDISTANCE DLD_DETECTORPOSITION

}'

def dld_var_init1() '{
 
  # c216 device name (without Tango:// prefix)
  global DLD_DEV_NOTANGOPREFIX
  # c216 full device name (= with Tango prefix)
  global DLD_DEV
  # devices crated in data collector
  global DLD_DC_EGY DLD_DC_SAMPLEDISTANCE DLD_DC_DETECTORPOSITION
  # flag idicating that devices were created in data collector
  global DLD_DCUP
  # RPC timeout for c216
  global DLD_RPCTIMEOUT
  # flag that tells if check is done on the presence of beam in 
  # exp. hutch before the acq. is started. Is made global just to
  # keep last choice as default when do next dldconfig.
  global DLD_BEAMCHECK

  # 2 possible signal polarities values for TFU ctrl i/p and c111 seq. o/p
  global DLD_POL_NORMAL DLD_POL_INVERSED
  # Constant defining if TFU is master(0) or slave(1)
  global DLD_TFU_MODE
  # Constant defining that TFU is master
  global DLD_TFUMASTER
  # Constant defining if TFU frame mode is time(0) or event(1) frames
  global DLD_TFU_FRAME_MODE
  # Constant defining that TFU frames are Time frames
  global DLD_TFUTIMEFRAME
  # number of TFU frames (= frame-pairs), cycles and 
  # max.nb of TFU frames (= frame-pairs) allowed 
  global DLD_NO_FRAMES DLD_NO_CYCLES DLD_MAX_FRAME_NUMBER
  # argin for frame info
  global DLD_FRAME_ARGIN[]
  # TFU output durign single live frame (set with dldsetliveout and
  # used in dldsettime)
  global DLD_LIVE_OUT
  # just filename and full filename with TFG frame info
  global DLD_FRFILE DLD_FULL_FRFILE
  # returned array of dead/live info
  global DLD_FRAME_INFO[]
  # Flag telling if TFU frame info is valid
  global DLD_FRAMES_VALID
  # Complete TFU config array (apart from detailed frame info)
  # The 28 fields in this array are the same as the first 28 fields
  # in DLD_STATUS[]
  global DLD_TFU_CONFIG[]
  # DLD start mode and 2 possible values: internal(0)/external(1))
  global DLD_START_MODE DLD_INTERNAL DLD_EXTERNAL

  # nb of TFU output port channels (O1->O4/O8)
  # nb of Digital Input channels   (I1->I4/I8)
  # nb of Analog  Input channels   (V1->V4/V8)
  global DLD_NO_CHANNELS
  # 2 possible values for some digi/analog input features
  global DLD_DIAN_DISABLE DLD_DIAN_ENABLE
  # 2 global arrays for digital and analog input config respectively
  global DLD_DIGI_IN[] DLD_ANA_IN[]

  # index of the bank selected for the acquisition
  global DLD_ACQ_BANK

  # dld status array and array of strings for status fields
  global DLD_STATUS[] DLD_STA_STR[]
  # dld start mode (internal/external);
  # keep it for backward compatibility (although have already DLD_START_MODE)
  global DLD_MODE
  # flag telling if dld used/not used in scans
  global DLD_ON

  # data grups:
  # DLD_GRP1 for TFU frame information
  # DLD_GRP3 for cumulated scaler info at the end of run
  #          for all 16(=DLD_SCALERS) scalers and up to 2K frame-pairs
  global DLD_GRP1 DLD_GRP3
  global DLD_GRP1_ON DLD_GRP3_ON
  # run number and old run number (needed to come back to 
  # run numbers used before scan)
  global DLD_RUN_NUMBER DLD_OLD_RUN_NUMBER
  # root file prefix and file prefix 
  global DLD_FILE_ROOT DLD_FILE_PREFIX 
  # data directory, header file name and data file name
  # for direct NFS mounted NICE file system
  global DLD_DATA_DIR DLD_HEADER_FILE

  # to denote number of scaler channels (= always 16 with C216)
  global DLD_SCALERS 
  #  
  global DLD_SCALER_NAME DLD_SCALER_ZERO DLD_SCALER_CALIB DLD_SCALER_X
  #
  global DLD_SCALER_I0 DLD_SCALER_I1 DLD_SCALER_ANODE DLD_SCALER_TIME
  #
  global DLD_I0_MONITOR DLD_I0 DLD_I1_MONITOR DLD_I1
  global DLD_ANODECOUNTS_MONITOR DLD_ANODECOUNTS
  global DLD_EXPOSURETIME_MONITOR DLD_EXPOSURETIME
  #

  global DLD_STOPFOREXTSTART

  global ONBEAMLINE

# new status array
  #
  # New complete config and status array (70 fields), obtained with command
  # GetCompleteConfigAndStatus()
  #
  # The first 28 fields are the same as obtained with GetTfuConfig()
  #
  DLD_STA_STR[0]="TFU mode                             : 0=master,1=slave     "
  DLD_STA_STR[1]="TFU frame mode                       : 0=time,1=event       "
  DLD_STA_STR[2]="External Start/FrameZero             : 0=disabled,1=enabled "
  DLD_STA_STR[3]="External Pause/Inhibit               : 0=disabled,1=enabled "
  DLD_STA_STR[4]="External Start/FrameZero Polarity    : 0=normal,1=inversed  "
  DLD_STA_STR[5]="Event/FrameClock    Polarity         : 0=normal,1=inversed  "
  DLD_STA_STR[6]="External Pause/Inhibit   Polarity    : 0=normal,1=inversed  "
  DLD_STA_STR[7]="C111 Sequencer      Polarity         : 0=normal,1=inversed  "
  DLD_STA_STR[8]="50 Ohms on TFU control inputs        : 0=off,1=on           "

  DLD_STA_STR[9]="End Of Run(EOR) Interrupt(master)    : 0=disabled,1=enabled "
  DLD_STA_STR[10]="End Of Cycle(EOC) Interrupt(master)  : 0=disabled,1=enabled "
  DLD_STA_STR[11]="Interrupt On Pause(OP)(master)       : 0=disabled,1=enabled "
  DLD_STA_STR[13]="Frames info in TFU frame memory      : 0=invalid,1=valid    "
  DLD_STA_STR[14]="Total number of TFU frames (when TFU master)                "
  DLD_STA_STR[15]="Total number of TFU live frames (when TFU master)           "
  DLD_STA_STR[16]="Total number of TFU internal pauses (when TFU master)       "
  DLD_STA_STR[17]="Total number of TFU cycles (when TFU master)                "
  DLD_STA_STR[18]="Estimated Cycle time in seconds (when time frames)          "
  DLD_STA_STR[19]="Number of valid/usefull TFU O/P port, Dig+Anal. In channels "
  DLD_STA_STR[20]="Default TFU Output on port O1        : 0=off,1=on           "
  DLD_STA_STR[21]="Default TFU Output on port O2        : 0=off,1=on           "
  DLD_STA_STR[22]="Default TFU Output on port O3        : 0=off,1=on           "
  DLD_STA_STR[23]="Default TFU Output on port O4        : 0=off,1=on           "
  DLD_STA_STR[24]="Default TFU Output on port O5        : 0=off,1=on           "
  DLD_STA_STR[25]="Default TFU Output on port O6        : 0=off,1=on           "
  DLD_STA_STR[26]="Default TFU Output on port O7        : 0=off,1=on           "
  DLD_STA_STR[27]="Default TFU Output on port O8        : 0=off,1=on           "

  DLD_STA_STR[28]="50 Ohms on Digital Input port I1     : 0=off,1=on           "
  DLD_STA_STR[29]="50 Ohms on Digital Input port I2     : 0=off,1=on           "
  DLD_STA_STR[30]="50 Ohms on Digital Input port I3     : 0=off,1=on           "
  DLD_STA_STR[31]="50 Ohms on Digital Input port I4     : 0=off,1=on           "
  DLD_STA_STR[32]="50 Ohms on Digital Input port I5     : 0=off,1=on           "
  DLD_STA_STR[33]="50 Ohms on Digital Input port I6     : 0=off,1=on           "
  DLD_STA_STR[34]="50 Ohms on Digital Input port I7     : 0=off,1=on           "
  DLD_STA_STR[35]="50 Ohms on Digital Input port I8     : 0=off,1=on           "

  DLD_STA_STR[36]="Glitch Filter on Digital Input p. I1 : 0=off,1=on           "
  DLD_STA_STR[37]="Glitch Filter on Digital Input p. I2 : 0=off,1=on           "
  DLD_STA_STR[38]="Glitch Filter on Digital Input p. I3 : 0=off,1=on           "
  DLD_STA_STR[39]="Glitch Filter on Digital Input p. I4 : 0=off,1=on           "
  DLD_STA_STR[40]="Glitch Filter on Digital Input p. I5 : 0=off,1=on           "
  DLD_STA_STR[41]="Glitch Filter on Digital Input p. I6 : 0=off,1=on           "
  DLD_STA_STR[42]="Glitch Filter on Digital Input p. I7 : 0=off,1=on           "
  DLD_STA_STR[43]="Glitch Filter on Digital Input p. I8 : 0=off,1=on           "
 
  DLD_STA_STR[44]="Digital Path on Analog Input port V1 : 0=disabled,1=enabled "
  DLD_STA_STR[45]="Digital Path on Analog Input port V2 : 0=disabled,1=enabled "
  DLD_STA_STR[46]="Digital Path on Analog Input port V3 : 0=disabled,1=enabled "
  DLD_STA_STR[47]="Digital Path on Analog Input port V4 : 0=disabled,1=enabled "
  DLD_STA_STR[48]="Digital Path on Analog Input port V5 : 0=disabled,1=enabled "
  DLD_STA_STR[49]="Digital Path on Analog Input port V6 : 0=disabled,1=enabled "
  DLD_STA_STR[50]="Digital Path on Analog Input port V7 : 0=disabled,1=enabled "
  DLD_STA_STR[51]="Digital Path on Analog Input port V8 : 0=disabled,1=enabled "

  DLD_STA_STR[52]="Input Gain on Analog Input   port V1 : 0=10V,1=2.5V full sc "
  DLD_STA_STR[53]="Input Gain on Analog Input   port V2 : 0=10V,1=2.5V full sc "
  DLD_STA_STR[54]="Input Gain on Analog Input   port V3 : 0=10V,1=2.5V full sc "
  DLD_STA_STR[55]="Input Gain on Analog Input   port V4 : 0=10V,1=2.5V full sc "
  DLD_STA_STR[56]="Input Gain on Analog Input   port V5 : 0=10V,1=2.5V full sc "
  DLD_STA_STR[57]="Input Gain on Analog Input   port V6 : 0=10V,1=2.5V full sc "
  DLD_STA_STR[58]="Input Gain on Analog Input   port V7 : 0=10V,1=2.5V full sc "
  DLD_STA_STR[59]="Input Gain on Analog Input   port V8 : 0=10V,1=2.5V full sc "

  DLD_STA_STR[60]="TFU current frame index                                     "
  DLD_STA_STR[61]="TFU current cycle index                                     "

  DLD_STA_STR[62]="TFU is in dead/live frame            : 0=Dead,1=Live Frame  "
  DLD_STA_STR[63]="TFU is not paused/paused             : 0=NotPaused,1=Paused "
  DLD_STA_STR[64]="TFU is not running/running           : 0=NotRunning,1=Runn. "

  DLD_STA_STR[65]="Index of currently selected memory bank                     "

  DLD_STA_STR[66]="End Of Run Interrupt Interrupt count                        "
  DLD_STA_STR[67]="End Of Cycle Interrupt Interrupt count                      "
  DLD_STA_STR[68]="Interrupt On Pause Interrupt count                          "
  DLD_STA_STR[69]="Interrupt On Start Interrupt count                          "

  # next 3 do not come from GetCompleteConfigAndStatus() command and are
  # therefore not in DLD_STATUS, but are in other variables defined in
  # this macro set.
  # TODO: see if need to define more fields here
  #       and add all these non-DLD_STATUS fields in dldshow,
  #       to display everything
  DLD_STA_STR[70]="0/1 = not save / save data to file                          "
  DLD_STA_STR[71]="0/1 = scaler acq. dis/enabled in scanning After mv+ct       "

  DLD_RPCTIMEOUT = 5 

  DLD_MAX_FRAME_NUMBER = 2048

  DLD_EPS = 1e-30;
  DLD_HC  = 1239.85;

  # I(FS) do not know why commented here since used later
  # In the version found on NERON it is not commented.
  # DLD_SEPARATOR=0xffffffff

  DLD_STOPFOREXTSTART = 0

  DLD_POL_NORMAL=0
  DLD_POL_INVERSED=1
  DLD_TFUMASTER = 0
  DLD_TFUTIMEFRAME = 0
  DLD_MINDEADSECONDS = 0.006
  DLD_MINDEADEVENTS = 2

  # Two possible TFU start modes (later also for pause)
  DLD_INTERNAL = 0
  DLD_EXTERNAL = 1
  # by default foresee internal start in dldacq
  TFG_TRIG = 0

  # Total nb of scalers (read always all 16 of them, although on P216
  # only half of them have valied values (= since on P216 only half of
  # scalers have corresponding input channels on P216)
  DLD_SCALERS = 16

  DLD_DIAN_DISABLE=0
  DLD_DIAN_ENABLE=1


  # TODO: if some global missing, put it here


  # initialisation of data group values and reservation of 
  # space (except for data group DLD_GRP3)
  DLD_GRP1 = 93   # for the TFU input frame info
  DLD_GRP1_ON = 1
  DLD_GRP3 = 95   # for all (16=DLD_SCALERS) scalers values 
                  # (for up to 2048=DLD_MAX_FRAME_NUMEBR frames=frame-pairs)
                  
  data_grp(DLD_GRP1,200,7)
  # next one is commented since DLD_GRP3 is recreated later (in dldstart)
  #data_grp(DLD_GRP3,DLD_MAX_FRAME_NUMBER,DLD_SCALERS)
  #DLD_GRP3_ON = 1

}'



#---------------------- DldConnect (internal macro) -------------
##
#  DldConnect 
##
#%IU%
#%MDESC%
#  Import devices and set timeouts
#
def dldconnect '{

  esrf_io(DLD_DEV,"tcp")
  esrf_io(DLD_DEV,"timeout",DLD_RPCTIMEOUT)

}'



#---------------------- DldDcup (internal macro) -------------
##
#  DldDcup 
##
#%IU%
#%MDESC%
#  Macro that creates devices for Data Collector
#
def dlddcup '{
  esrf_dc(DLD_DC_EGY,"create","DevRead","D_DOUBLE_TYPE");
  esrf_dc(DLD_DC_SAMPLEDISTANCE,"create","DevRead","D_DOUBLE_TYPE");
  esrf_dc(DLD_DC_DETECTORPOSITION,"create","DevRead","D_DOUBLE_TYPE");

  DLD_DCUP = 1
}'



#---------------------- DldCleanup (internal macro) -------------
##
#  DldCleanup 
##
#%IU%
#%MDESC%
#  Macro executed at cleanup (ctrl-C)
#
def _dld_cleanup '{

  local dldstopall dld_ststring
  #
  # Check if an acquistion is running
  #
  # If yes, stop it
  #
  dldstopall = 0
  if (dld_isrunning()) {
    printf("There is a C216 acquisition running\n")
    dldstopall = yesno("Do you want to stop the current acquisition",0)
  }

  if (dldstopall == 1 ) {
    dld_unset
    dldstop
  } else {
    dldpoll
  }

}'


#---------------------- DldSetup_OLD --------------------------------
##
#  DldSetup_OLD
##
#%UU% [c216_dev dir energy_dc sample-distance_dc detector-position_dc] :
#%MDESC%
#  The following parameters have to be given with this command
#  or it will ask for them interactively:
#  - c216_dev:            c216 Tango device name 
#  - energy_dc:           name for energy device in data collector
#                         it must follow device nomenclature. i.e
#                         domain/family/member and be the same as
#                         that in monochromator spec application
#  - sample-distance_dc   name for sample distance in data collector
#  - detector-position_dc name for detector position in data collector
#
def dldsetup_OLD '{

  local sowhat stalen

  dld_var_init()

  c216version

  printf("dldsetup: Number of arguments = %d\n", $#)

  if ($# != 4 && $# !=0 ) {
    print "Usage: dldsetup [c216_dev(without Tango prefix) energy_dc sample-distance_dc detector-position_dc]"
   exit
  }

  #
  # Show current setup.
  #
  if ($# == 0 ) {
    printf("Current parameters for dld setup\n\n")
    printf("C216 device                     : %s\n",DLD_DEV)
    printf("\nData collector devices:\n")
    printf("\tEnergy            :     %s\n",DLD_DC_EGY)
    printf("\tSample Distance   :     %s\n",DLD_DC_SAMPLEDISTANCE)
    printf("\tDetector Position :     %s\n",DLD_DC_DETECTORPOSITION)

    sowhat = yesno("\nDo you want to change setup values",0)
    if (sowhat == 0) exit
    ONBEAMLINE = 1
    DLD_DEV_NOTANGOPREFIX=getval("  C216 Tango Device name(without prefix) ",DLD_DEV_NOTANGOPREFIX)
    DLD_DEV=sprintf("Tango://%s", DLD_DEV_NOTANGOPREFIX)
    printf("\n")
    DLD_DC_EGY    =getval("Data coll. device for energy ",DLD_DC_EGY)
    DLD_DC_SAMPLEDISTANCE   =getval("D.c. device for sample dist. ",DLD_DC_SAMPLEDISTANCE)
    DLD_DC_DETECTORPOSITION =getval("D.c. device for detector pos.",DLD_DC_DETECTORPOSITION)
  }

  if ($# == 4) {
    DLD_DEV_NOTANGOPREFIX="$1"; 
    DLD_DEV=sprintf("Tango://%s", DLD_DEV_NOTANGOPREFIX)
    DLD_DC_EGY="$2"; DLD_DC_SAMPLEDISTANCE="$3";
    DLD_DC_DETECTORPOSITION="$4";
  }

  #
  # First import and timeouts
  #
  dldconnect

  ######if (DLD_DCUP == 0) dlddcup
  dlddcup

  if (esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",DLD_STATUS) < 0) {
    printf("Error reading C216 status\n")
    exit
  } 

}'



#---------------------- dldsetup ------------------------------
#%UU% <device_name> <rpc_timeout>
#%MDESC%
#  This macro must normally be invoked at spec session start
#  after C216 macro set is loaded.
#  The following parameters have to be given with this command
#  or it will ask for them interactively:
#  - device_name: C216 device name(without Tango:// prefix, which is added here)
#  - rpc_timeout: RPC timeout
#
# TODO: see if RPC timeout still good think since have Tango server
# TODO: later add here scaler assignment
#
def dldsetup '{
    local answ

    if ($# > 2) {
        print "Usage: $0 [<C216_device_name(without Tango prefix)>] [<RPC_timeou
t(sec)]>"
        exit
    }

    #_dld_varinit
    dld_var_init()
    c216version

    if ($# == 2) {
        DLD_DEV_NOTANGOPREFIX = "$1"
        DLD_RPCTIMEOUT = $2
        DLD_DEV=sprintf("Tango://%s", DLD_DEV_NOTANGOPREFIX)
        if (DLD_RPCTIMEOUT < 3) DLD_RPCTIMEOUT = 3
    } else {
        # can have 1(=device name) or zero args
        printf("\nRPC timeout = %d\n", DLD_RPCTIMEOUT)
        answ = yesno("Do you want to change it",0)
        if (answ) {
            DLD_RPCTIMEOUT=getval("RPC timeout in seconds ",DLD_RPCTIMEOUT)
            if (DLD_RPCTIMEOUT < 3) DLD_RPCTIMEOUT = 3
        }
        if ($# == 0) {
            printf("\nC216 Device = %s\n", DLD_DEV)
            answ = yesno("Do you want to change it",0)
            if (answ) {
                DLD_DEV_NOTANGOPREFIX=getval("C216 Device name(without Tango pre
fix) ",DLD_DEV_NOTANGOPREFIX)
                DLD_DEV=sprintf("Tango://%s",DLD_DEV_NOTANGOPREFIX)
            }
        } else {
            DLD_DEV_NOTANGOPREFIX="$1"
            DLD_DEV=sprintf("Tango://%s",DLD_DEV_NOTANGOPREFIX)
        }
    }

    # --- import C216 Tango device and set timeout
    dldconnect

    # --- check CUB status (Low Voltages + PLL locks)
    if (_dld_cubstatus()) {
        # CUB status OK
        # --- get now C216 complete config+status
        if (_dld_getstatus()) {
            # C216 status OK
            # --- check that TFU is master (do not cover slave mode!)
            if (DLD_TFU_MODE != DLD_TFUMASTER) {
                printf("****** TFU is NOT Master!!!!!!!!!!!!!!!!!!!!!******\n")
                printf("****** Should not use these set of macros!!!!******\n")
                printf("****** They are made only for TFU masters!!!!******\n")
            }
        }


    }
    cdef("cleanup_always","_dld_cleanup; ","dldset")
    setup_tail("dld")

}'



#---------------------- DldConfigAll (internal macro)-------
##
#  DldConfigAll 
##
#%IU% 
#%MDESC%
#  Macro that executes the configuration (of TFU,
#  except the number of cycles in TFU).
#  Reads frame information from DLD_FULL_FRFILE and programs
#  TFU frame memory.
#  Called from dldconfig and dldacq.
#
def dldconfigall '{

  local no_groups i dld_arg_len 
  local DLD_FRAME_ARG
  #
  # Reads the frame info from file. 
  # If first argument is "nofile" (the case when macro is called
  # from dldacq) file reading is skipped, since DLD_FRAME_ARGIN
  # is prepared directly on the basis of live time.
  #
  if ("$1" != "nofile") {
    no_groups=data_read(DLD_FULL_FRFILE,DLD_GRP1,0,0)
    if (no_groups == -1) {
      print "Dld: error in opening frame information file"
      exit
    }
    #
    # Now prepare argin.
    # 
    for(i=0;i<no_groups;i++) {
      #print i
      DLD_FRAME_ARG[i*7]=data_get(DLD_GRP1,i,0)
      DLD_FRAME_ARG[i*7 + 1]=data_get(DLD_GRP1,i,1)
      DLD_FRAME_ARG[i*7 + 2]=data_get(DLD_GRP1,i,2)
      DLD_FRAME_ARG[i*7 + 3]=data_get(DLD_GRP1,i,3)
      DLD_FRAME_ARG[i*7 + 4]=data_get(DLD_GRP1,i,4)
      DLD_FRAME_ARG[i*7 + 5]=data_get(DLD_GRP1,i,5)
      DLD_FRAME_ARG[i*7 + 6]=data_get(DLD_GRP1,i,6)
    }
  }

  if ("$1" != "nofile") {
    dld_arg_len=esrf_io(DLD_DEV,"SetTfuFrames0",DLD_FRAME_ARG,DLD_FRAME_INFO)
  } else {
    dld_arg_len=esrf_io(DLD_DEV,"SetTfuFrames0",DLD_FRAME_ARGIN,DLD_FRAME_INFO)
  }
  if(dld_arg_len==-1) {
    printf("Error setting frames in frame memory\n")
    exit
  } else {
    # Shows TFU configuration as returned after programming TFG.
    for (i=0;i<dld_arg_len;i+=2) {
      printf("Frame %d, dead time: %f\n",(i+2)/2,DLD_FRAME_INFO[i])
      printf("          live time: %f\n",DLD_FRAME_INFO[i+1])
    }
    DLD_NO_FRAMES = dld_arg_len/2
  }

}'


#---------------------- DldNoCycles (internal macro)-------
##
#  DldNoCycles 
##
#%IU%
#%MDESC%
#  Macro that sets number of cycles in TFG
#  Called from dldconfig and dldacq.
#
def dldnocycles '{

  local dld_return

  dld_return = esrf_io(DLD_DEV,"SetTfuCycles",DLD_NO_CYCLES) 
  if (dld_return == -1 ) {
    printf("Error setting number of TFU cycles in C216\n")
  }

}'



#---------------------- Dld_Head (internal macro) ------------------
##
#  Dld_Head 
##
#%IU%
#%MDESC%
#  Defines initial partition and run number to be used in 
#  scan.
#
def dld_head '{

  DLD_RUN_NUMBER = 0
  if (DATAFILE != "") {
    ond;offt
    printf("#U %s%.3d ; dld file prefix \n",DLD_FILE_ROOT,SCAN_N)
    offd;ont
  }

}'



#---------------------- Dld_Loop (internal macro) ------------------
##
#  Dld_Loop 
##
#%IU%
#%MDESC%
#  Defines dld related operation in each scan point
#  Is executed in each scan point after mv and ct.
#
def dld_loop '{

  DLD_FILE_PREFIX = sprintf("%s%.3d-",DLD_FILE_ROOT,SCAN_N)
  p DLD_FILE_PREFIX
  # suppose here always internal start
  dldstart 0
    
  # check the presence of beam in exp hutch
  # (N.B. this is always done, independent of the choice in dldconfig)
#  beamcheck; while (!BCHK_BEAM) {
    ####beampoll
    # suppose here always internal start
    dldstart 0 
#    beamcheck
  }

  # before reading the partition data, poll to see when 
  # acq. is over. In this loop also refresh SHM for display 
  dldpoll  

  # make dldresume of a single frame
  # If >1 frame are used in TFG (which is very unlikey in scan)
  # will see only report on the first one with dld_resume.
  # To get report on all frames must make a loop over frames 
  # in which dld_resume is called for each frame.
  # TODO: Uncomment if does not disturb too much during the scan)
  ##dld_resume(1)

  dldsave

}'



#---------------------- DldScanOn (internal macro) ------------------
##
#  DldScanOn 
##
#%IU%
#%MDESC%
#  Enables Dld acquisition at each scan point. Called from
#  dldconfig. 
#  Note that dld acquisition in scan is done after mv & ct
#  unlike on ID01, where the sequence is: mv, start acq,
#  ct, stop acq + transfer data. On ID01 the situation is 
#  simple (only 1 image/partition) and VTDC4 is defining 
#  the timing. On ID13 (in general for time-resolved cases)
#  the reason to do all dld acquisition after mv and ct is
#  that once dldstart is made it doesn't give hand back. In 
#  addition can have complicated TFU info and would be difficult
#  to make ct corresponding to it.
# 
def dldscanon '{

  if (DLD_ONCTSC) {
    dldoff
  }

  if (!DLD_ON) {
    DLD_OLD_RUN_NUMBER = DLD_RUN_NUMBER
    DLD_ON = 1
  }

  rdef scan_head \'
    _head
    dld_head
    \'

  rdef scan_loop \'
    _loop
    dld_loop
    \'
}'



#---------------------- DldScanOff (internal macro) ------------------
##
#  DldScanOff 
##
#%IU%
#%MDESC%
#  Disables Dld acquisition at each scan point. Called from
#  dldconfig
# 
def dldscanoff '{

  if (DLD_ON) {
    DLD_RUN_NUMBER = DLD_OLD_RUN_NUMBER
    DLD_ON = 0
  }

  rdef scan_head \'
    _head
    \'
  rdef scan_loop \'
    _loop
    \'
}' 



#---------------------- DldNewFile --------------------------
##
#  DldNewFile 
##
#%UU% [<file-prefix> <run-number>]
#%MDESC%
# Choose a new output file prefix and set general info
# If the run number is not passed as argument and if the filename is changed,
# it is reset to 0
#
# Usage: dldnewfile <file-prefix> <directory> <run-number>
#
def dldnewfile '{
 
   if (DLD_FILE_ROOT  == 0) DLD_FILE_ROOT="test"

   if ($# == 0) {
     DLD_FILE_PREFIX = getval("Prefix for output file names",DLD_FILE_ROOT)
     DLD_RUN_NUMBER  = getval("Series number", DLD_RUN_NUMBER) - 1
     DLD_DATA_DIR    = getval("Directory for header and data",DLD_DATA_DIR)
   } else if ($# == 1) {
     DLD_FILE_PREFIX = "$1"
     if (DLD_FILE_PREFIX!=DLD_FILE_ROOT) DLD_RUN_NUMBER = 0
   } else if ($# == 2) {
     DLD_FILE_PREFIX = "$1"
     DLD_DATA_DIR    = "$2"
   } else if ($# == 3) {
     DLD_FILE_PREFIX = "$1"
     DLD_DATA_DIR    = "$2"
     DLD_RUN_NUMBER  = $3
   } else if ($# > 3) {
     printf("Usage: dldnewfile <file-prefix> <directory> <run-number>\n")
     exit
   }
   DLD_FILE_ROOT=DLD_FILE_PREFIX

}'



#---------------------- DldConfig --------------------------
##
#  DldConfig 
##
#%UU%
#%MDESC%
#  Ask for values to prepare a new configuration for an acquistion
#  and make them effective.
#  The values asked are:
#    Name of directory where to store header and data
#    Filename of the file with TFG frame information
#    If want to do Dld acq. in each scan point
#    Number of TFU cycles
#    If want to do beam check (in which case acquisition is started only 
#    if there is beam in the hutch)
#    N.B. beamcheck.mac must be loaded together with dld.mac
#
def dldconfig '{
local dldstopall

  # check first if the acq. is running
  if (dld_isrunning()) {
    printf("There is a DLD acquistion running\n")
    printf("You cannot reconfigure the hardware while running\n")
    dldstopall = yesno("Do you want to stop the current acquisition",1)
    if (dldstopall == 0) exit
    else {
      dldstop
    }
  }

  # some default initialisations 
  if (DLD_FRFILE       == 0) DLD_FRFILE      = "vilong"
  if (DLD_FILE_ROOT    == 0) DLD_FILE_ROOT   = "test"

  if ($# >= 4) {
    # use arguments    
    DLD_FRFILE      = "$1"
    DLD_FULL_FRFILE = sprintf("%s/frames/%s",HOME,DLD_FRFILE)
    DLD_ON          = $2
    DLD_NO_CYCLES   = $3
    DLD_BEAMCHECK   = $4
  } else {
    # ask user for values
    DLD_FRFILE      =getval("Frame information file name" ,DLD_FRFILE)
    DLD_FULL_FRFILE =sprintf("%s/frames/%s",HOME,DLD_FRFILE)
    DLD_ON          =yesno("Do a Dld acq+transfer after each scan point ",DLD_ON)
    DLD_NO_CYCLES   =getval("No_cycles",1)
    DLD_BEAMCHECK=yesno("Do you want to activate the beamcheck", DLD_BEAMCHECK)
  }

  if (DLD_BEAMCHECK) {
    if ($# == 8) {
#      beamchecksetup $5 $6 $7 $8
    } else {
#      beamchecksetup
    }
#    beamcheckon
  } else {
#    beamcheckoff
  }

  if (DLD_ON == 1) {
    dldscanon
  } else {
    dldscanoff
  }

  #
  # Execute configuration 
  #
  dldnocycles
  dldconfigall

  # TODO: Here would be the place for dldscalersetup ??
  #       and dldscalerassign (now dldscalerassign called from dldinfo)   


}'



#---------------------- _Dld_GetStatus() ------------------------------
#%IU% ()
#%MDESC%
#  Read C216 status and update some global variables %BR%
#  Return 1 on success, 0 otherwise
def _dld_getstatus() '{
    local i
    if (esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",DLD_STATUS) < 0) {
        return (0)
    }

    # copy some most important config fields into specific global variables
    # certain variables like DLD_FRAMES_VALID, DLD_NO_FRAMES,
    # DLD_NO_CYCLES have meaning only when TFU = Master
    # TODO: introduce other globals if necessary

    DLD_TFU_MODE       = DLD_STATUS[0]
    DLD_TFU_FRAME_MODE = DLD_STATUS[1]
    DLD_START_MODE     = DLD_STATUS[2]

    DLD_FRAMES_VALID   = DLD_STATUS[13]
    # divide DLD_STATUS[14] by 2 to get nb of frame pairs (D+L)
    # this number is also equal to nb of live frames
    DLD_NO_FRAMES      = DLD_STATUS[14]/2
    DLD_NO_CYCLES      = DLD_STATUS[17]

    DLD_NO_CHANNELS    = DLD_STATUS[19]

    DLD_ACQ_BANK       = DLD_STATUS[65]

    # some more copies
    for (i = 0; i < 28; i++) {
        DLD_TFU_CONFIG[i] = DLD_STATUS[i]
    }

    for (i = 0; i < DLD_NO_CHANNELS; i++) {
        DLD_DIGI_IN[i]   = DLD_STATUS[28+i]
        DLD_DIGI_IN[i+8] = DLD_STATUS[36+i]
        DLD_ANA_IN[i]    = DLD_STATUS[44+i]
        DLD_ANA_IN[i+8]  = DLD_STATUS[52+i]
    }

    return (1)
}'



#-------------------------- dldshow ---------------------------
#%UU%
#%MDESC%
#  Shows COMPLETE C216 config/status parameters
#  Treat also TFU=Slave case, although these macros
#  are meant to cover only TFU=Master case
#  Assume that before invoking this macro dldstatus was done
#  to get fresh DLD_STATUS[] info.
#
def dldshow '{ _dld_show() }'
def _dld_show() '{
    local i
    local outport, fiftyohms, glitchfilter, digitalpath, inputgain
    local intendis, itcnts
    nl= 0

    tty_cntl("ho"); tty_cntl("cd")
    tty_move(12, nl++, "\[md\]< C216 CONFIGURATION+STATUS >\[me\]")
    tty_move(10, nl++, sprintf("Device Name : \[md\]%s\[me\]", DLD_DEV))
    nl++

    tty_move(0, nl, "* TFU Mode ...........................")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_TFU_MODE?"Slave":"Master"))
    if (DLD_TFU_MODE != DLD_TFUMASTER) {
	printf("This set of macros cover only TFU = Master case\n")
        exit
    }

    # continue only for TFU = Master 
    tty_move(0, nl, "* TFU Frame Mode .....................")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_TFU_FRAME_MODE?"Event":"Time"))
    if (DLD_TFU_FRAME_MODE != DLD_TFUTIMEFRAME) {
        # event frame
        tty_move(0, nl, "* Event Input Polarity................")
        tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
                 DLD_STATUS[5]?"Inversed":"Normal"))
    }

    tty_move(0, nl, "* TFU Start Mode .....................")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_START_MODE?"External":"Internal"))
    tty_move(0, nl, "* TFU Start Mode for dldacq...........")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
                 TFG_TRIG?"External":"Internal"))
    if (DLD_START_MODE == DLD_EXTERNAL) {
        # external start enabled -> show ext.start input polarity
        tty_move(0, nl, "* External Start Input Polarity.......")
        tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
                 DLD_STATUS[4]?"Inversed":"Normal"))
    }
    if (DLD_STATUS[3] == DLD_EXTERNAL) {
        # external pause = enabled -> show ext.pause input polarity
        tty_move(0, nl, "* External Pause Input Polarity.......")
        tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
                 DLD_STATUS[6]?"Inversed":"Normal"))
    }
    tty_move(0, nl, "* C111 Sequencer Polarity.............")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_STATUS[7]?"Inversed":"Normal"))
    tty_move(0, nl, "* 50 Ohms on TFU Control Inputs.......")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_STATUS[8]?"Enabled":"Disabled"))
    tty_move(0, nl, "* Interrupt: EOR,EOC,OnPause,OnStart..")
    itendis=""
    itendis=sprintf("%s%s",itendis,  DLD_STATUS[9]?"En":"Dis")
    itendis=sprintf("%s %s",itendis,  DLD_STATUS[10]?"En":"Dis")
    itendis=sprintf("%s %s",itendis,  DLD_STATUS[11]?"En":"Dis")
    itendis=sprintf("%s %s",itendis,  DLD_STATUS[12]?"En":"Dis")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]",itendis))
    tty_move(0, nl, "* Frame Info in Frame Memory .........")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_FRAMES_VALID?"Valid":"NotValid"))
    tty_move(0, nl, "* Total nb of frame-pairs.............")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_NO_FRAMES))
    tty_move(0, nl, "* Total nb of live frames.............")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_STATUS[15]))
    tty_move(0, nl, "* Total nb of internal pauses.........")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_STATUS[16]))
    tty_move(0, nl, "* Total nb of TFU cycles..............")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_NO_CYCLES))
    if (DLD_TFU_FRAME_MODE == DLD_TFUTIMEFRAME) {
        # time frame
        tty_move(0, nl, "* Estimated cycle time[s].............")
        tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_STATUS[18]))
    }
    tty_move(0, nl, "* Nb of chan. of each kind (O,I,V)....")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_NO_CHANNELS))

    tty_move(0, nl, "* Dflt TFU out port (O1->O8) pattern..")
    outport=""
    for (i = 20; i < 28; i++) {
        if (i == 20) outport=sprintf("%s%s",outport,  DLD_STATUS[i]?"On":"Off")
        else         outport=sprintf("%s %s",outport, DLD_STATUS[i]?"On":"Off")
    }
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]",outport))

    tty_move(0, nl, "* 50 Ohms on Digital Inputs  I1->I8...")
    fiftyohms=""
    for (i = 28; i < 36; i++) {
        if (i == 28) fiftyohms=sprintf("%s%s",fiftyohms, DLD_STATUS[i]?"En":"Dis")
        else         fiftyohms=sprintf("%s %s",fiftyohms,DLD_STATUS[i]?"En":"Dis")
    }
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]",fiftyohms))

    tty_move(0, nl, "* Glitch Filter on Dig. Inp. I1->I8...")
    glitchfilter=""
    for (i = 36; i < 44; i++) {
        if (i == 36) glitchfilter=sprintf("%s%s",glitchfilter, DLD_STATUS[i]?"En":"Dis")
        else         glitchfilter=sprintf("%s %s",glitchfilter,DLD_STATUS[i]?"En":"Dis")
    }
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]",glitchfilter))

    tty_move(0, nl, "* Digital Path on Analog Inp.V1->V8...")
    digitalpath=""
    for (i = 44; i < 52; i++) {
        if (i == 44) digitalpath=sprintf("%s%s",digitalpath, DLD_STATUS[i]?"En":"Dis")
        else         digitalpath=sprintf("%s %s",digitalpath,DLD_STATUS[i]?"En":"Dis")
    }
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]",digitalpath))

    tty_move(0, nl, "* V2F Gain on Analog Inputs  V1->V8...")
    inputgain=""
    for (i = 52; i < 60; i++) {
        if (i == 52) inputgain=sprintf("%s%s",inputgain, DLD_STATUS[i]?"2.5V":"10V")
        else         inputgain=sprintf("%s %s",inputgain,DLD_STATUS[i]?"2.5V":"10V")
    }
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]",inputgain))

    tty_move(0, nl, "* Current TFU frame index.............")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_STATUS[60]))
    tty_move(0, nl, "* Current TFU cycle index.............")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_STATUS[61]))
    tty_move(0, nl, "* TFU current frame type is...........")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", DLD_STATUS[62]?"Live":"Dead"))
    tty_move(0, nl, "* TFU current paused state is.........")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_STATUS[63]?"Paused":"NotPaused"))
    tty_move(0, nl, "* TFU current run state is............")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", \
             DLD_STATUS[64]?"Running":"NotRunning"))
    tty_move(0, nl, "* Index of bank selected for acq......")
    tty_move(40, nl++, sprintf("\[md\]%d\[me\]", DLD_ACQ_BANK))
    tty_move(0, nl, "* Int Cnts: EOR,EOC,OnPause,OnStart...")
    itcnts=""
    itcnts=sprintf("%s%d",itcnts, DLD_STATUS[66])
    itcnts=sprintf("%s %d",itcnts, DLD_STATUS[67])
    itcnts=sprintf("%s %d",itcnts, DLD_STATUS[68])
    itcnts=sprintf("%s %d",itcnts, DLD_STATUS[69])
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", itcnts))
    tty_move(0, nl, "* Save Scalers Data into file.........")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", DLD_STATUS[70]?"Yes":"No"))
    tty_move(0, nl, "* Scaler Acq in ct &  ct in scan......")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", DLD_ON?"Yes":"No"))
    tty_move(0, nl, "* Scaler Acq in scan After mv_ct......")
    tty_move(40, nl++, sprintf("\[md\]%s\[me\]", DLD_SCANON?"Enabled":"Disabled"))
    return (++nl)
}'



# next one is made, not to have Pbs in dldaddconfig
def _dld_show1() '{
    local i
    local outport, fiftyohms, glitchfilter, digitalpath, inputgain

    printf("\n\n")
    printf("TFU Mode ...........................  %s\n",\
            DLD_TFU_MODE?"Slave":"Master")
    if (DLD_TFU_MODE != DLD_TFUMASTER) {
	printf("This set of macros cover only TFU = Master case\n")
        exit
    }
    # continue only for TFU = Master 

    printf("TFU Frame Mode .....................  %s\n",\
            DLD_TFU_FRAME_MODE?"Event":"Time")
    if (DLD_TFU_FRAME_MODE != DLD_TFUTIMEFRAME) {
        # event frame
        printf("Event Input Polarity................  %s",\
                DLD_STATUS[5]?"Inversed":"Normal")
    }
    printf("TFU Start Mode .....................  %s\n",\
            DLD_START_MODE?"External":"Internal")
    printf("TFU Start Mode for dldacq...........  %s\n",\
            TFG_TRIG?"External":"Internal")
    if (DLD_START_MODE == DLD_EXTERNAL) {
        # external start enabled -> show ext.start input polarity
        printf("External Start Input Polarity.......  %s\n",\
                DLD_STATUS[4]?"Inversed":"Normal")
    }
    if (DLD_STATUS[3] == DLD_EXTERNAL) {
        # external pause = enabled -> show ext.pause input polarity
        printf("External Pause Input Polarity.......  %s\n",\
                DLD_STATUS[6]?"Inversed":"Normal")
    }
    printf("C111 Sequencer Polarity.............  %s\n",\
            DLD_STATUS[7]?"Inversed":"Normal")
    printf("50 Ohms on TFU Control Inputs.......  %s\n",\
            DLD_STATUS[8]?"Enabled":"Disabled")

    itendis=""
    itendis=sprintf("%s%s",itendis,  DLD_STATUS[9]?"En":"Dis")
    itendis=sprintf("%s %s",itendis,  DLD_STATUS[10]?"En":"Dis")
    itendis=sprintf("%s %s",itendis,  DLD_STATUS[11]?"En":"Dis")
    itendis=sprintf("%s %s",itendis,  DLD_STATUS[12]?"En":"Dis")
    printf("Interrupt: EOR,EOC,OnPause,OnStart..  %s\n",itendis)
    printf("Frame Info in Frame Memory .........  %s\n",\
            DLD_FRAMES_VALID?"Valid":"NotValid")
    printf("Total nb of frame-pairs.............  %d\n", DLD_NO_FRAMES)
    printf("Total nb of live frames.............  %d\n", DLD_STATUS[15])
    printf("Total nb of internal pauses.........  %d\n", DLD_STATUS[16])
    printf("Total nb of TFU cycles..............  %d\n", DLD_NO_CYCLES)
    if (DLD_TFU_FRAME_MODE == DLD_TFUTIMEFRAME) {
        # time frame
        printf("Estimated cycle time[s].............  %d\n",DLD_STATUS[18])
    }
    printf("Nb of chan. of each kind (O,I,V)....  %d\n",DLD_NO_CHANNELS)
    outport=""
    for (i = 20; i < 28; i++) {
        if (i == 20) outport=sprintf("%s%s",outport,  DLD_STATUS[i]?"On":"Off")
        else         outport=sprintf("%s %s",outport, DLD_STATUS[i]?"On":"Off")
    }
    printf("Dflt TFU out port (O1->O8) pattern..  %s\n", outport)
    fiftyohms=""
    for (i = 28; i < 36; i++) {
        if (i == 28) fiftyohms=sprintf("%s%s",fiftyohms, DLD_STATUS[i]?"En":"Dis")
        else         fiftyohms=sprintf("%s %s",fiftyohms,DLD_STATUS[i]?"En":"Dis")
    }
    printf("50 Ohms on Digital Inputs  I1->I8...  %s\n",fiftyohms)
    glitchfilter=""
    for (i = 36; i < 44; i++) {
        if (i == 36) glitchfilter=sprintf("%s%s",glitchfilter, DLD_STATUS[i]?"En":"Dis")
        else         glitchfilter=sprintf("%s %s",glitchfilter,DLD_STATUS[i]?"En":"Dis")
    }
    printf("Glitch Filter on Dig. Inp. I1->I8...  %s\n",glitchfilter)
    for (i = 44; i < 52; i++) {
        if (i == 44) digitalpath=sprintf("%s%s",digitalpath, DLD_STATUS[i]?"En":"Dis")
        else         digitalpath=sprintf("%s %s",digitalpath,DLD_STATUS[i]?"En":"Dis")
    }
    printf("Digital Path on Analog Inp.V1->V8...  %s\n",digitalpath)
    inputgain=""
    for (i = 52; i < 60; i++) {
        if (i == 52) inputgain=sprintf("%s%s",inputgain, DLD_STATUS[i]?"2.5V":"10V")
        else         inputgain=sprintf("%s %s",inputgain,DLD_STATUS[i]?"2.5V":"10V")
    }
    printf("V2F Gain on Analog Inputs  V1->V8...  %s\n",inputgain)
    printf("Current TFU frame index.............  %d\n",DLD_STATUS[60])
    printf("Current TFU cycle index.............  %d\n",DLD_STATUS[61])
    printf("TFU current frame type is...........  %s\n",DLD_STATUS[62]?"Live":"Dead")
    printf("TFU current paused state is.........  %s\n",\
            DLD_STATUS[63]?"Paused":"NotPaused")
    printf("TFU current run state is............  %s\n",\
            DLD_STATUS[64]?"Running":"NotRunning")
    printf("Index of bank selected for acq......  %d\n",DLD_ACQ_BANK)
    itcnts=""
    itcnts=sprintf("%s%d",itcnts, DLD_STATUS[66])
    itcnts=sprintf("%s %d",itcnts, DLD_STATUS[67])
    itcnts=sprintf("%s %d",itcnts, DLD_STATUS[68])
    itcnts=sprintf("%s %d",itcnts, DLD_STATUS[69])
    printf("Int Cnts: EOR,EOC,OnPause,OnStart...  %s\n",itcnts)
}'



#---------------------- dldsetctrlin ---------------------
#%UU% 
#%MDESC%
#  Sets TFU control inputs %BR%
#  These inputs are: event/fr.clock, ext.start/fr.zero,
#  ext.pause/ext.inhibit, c111 sequencer (is in fact an output)
#  The corresponding config values can be passed in input argument.
#  If no arguments, then user interactively selects new control
#  inputs configuration.
#
def dldsetctrlin '{
    local event_pol ext_start_pol ext_pause_pol c111_seq_pol 
    local ctrl_ip_50Ohms

    if (($# != 0) && ($# != 6)) {
        print "Usage: $0 [<startmode(for dldacq)> <event polarity> <ext. start polarity> <ext. pause polarity> <c111 seq. polarity> <50 Ohms on ctrl inputs>]"
        exit
    }

    if (!_dld_getstatus()) {
        printf("Error getting complete config+status\n")
	exit
    }

    if ($# == 0) {
        # -- collect control inputs configuration parameters interactively

        # -- TFU start mode (for macros like dldacq). Is not set in hardware
        #    here(= in this macro). Macro dldstart does not need it, since 
        #    int/ext mode is passed to it in argin
        #    TODO: Ideally should drop this variable and use one more parameter
        #          in dldacq (for ex. the 1st one, as for dldstart)
        TFG_TRIG = getval(" - TFU Start Mode in dldacq<0=internal/1=external>    ", DLD_START_MODE)

        if (DLD_TFU_FRAME_MODE != DLD_TFUTIMEFRAME) { 
            event_pol = getval(" - Event input polarity<0=normal/1=inversed> ",\
                                   DLD_STATUS[5])
        } else {
            event_pol = DLD_POL_NORMAL  # could also set DLD_STATUS[5]
        }
        # -- Do not set here in the hardware external start/pause 
        #    enable/disable feature.
        #    This is done in macros like dldstart, dldacq ...
        # -- Ask only for these inputs polarities in case this features
        #    are used later. Since all 4 polarities are set with the same
        #    command, for those not used, keep current value or set it to 
        #    normal.
        # -- Since at some point in dldstart can use external start, choose
        #    here external start polarity independent of TFG_TRIG (which is
        #    only for dldacq)
        #if (TFG_TRIG == DLD_EXTERNAL) {
        # ext_start_pol = getval(" - Ext start polarity<0=normal/1=inversed> ",\
        #                               DLD_STATUS[4])
        #} else {
        #    ext_start_pol = DLD_POL_NORMAL
        #}
        ext_start_pol = getval(" - Ext start polarity<0=normal/1=inversed> ",\
                                   DLD_STATUS[4])
        # TODO: activate later (when pause is implemented in server)
        #       For the moment set it to be normal
        #ext_pause_pol = getval(" - Ext pause polarity<0=normal/1=inversed> ",\
        #                           DLD_STATUS[6])
        ext_pause_pol = DLD_POL_NORMAL  # could also set DLD_STATUS[6]
        c111_seq_pol  = getval(" - C111 seq. polarity<0=normal/1=inversed> ",\
                                   DLD_STATUS[7])
        # -- 50 Ohms on TFU control inputs
        ctrl_ip_50Ohms= getval(" - 50 Ohms on TFU ctrl i/p <0=dis/1=enab> ", \
                                   DLD_STATUS[8])
        # -- Do not manipulate enabling/disabling interrupts here
        #    Again this is in hands of macros calling commands that do
        #    start/pause/stop/reset
    } else {
        TFG_TRIG = $1
        event_pol = $2
        ext_start_pol = $3
        ext_pause_pol = $4
        c111_set_pol = $5
        ctrl_ip_50Ohms = $6
    }

    if (!_dld_setctrlin(event_pol, ext_start_pol, ext_pause_pol, c111_seq_pol, ctrl_ip_50Ohms)) {
        printf("Error setting ctrl input polarity/ies and/or 50 Ohms\n")
    } else {
        # make next call in case dldshow is invoked immediately after
        # successfull invocation of dldsetctrlin in order to get 
        # true/correct/fresh information from the hardware
        _dld_getstatus()  
    }
}'

#%IU% (event pol, ext_start pol, ext_pause pol, c111_seq_pol, ctrl_ip_50Ohms)
#%MDESC%
#  Sets TFU control inputs %BR%
#  Return 1 on success, 0 otherwise
def _dld_setctrlin(event_p,ext_start_p,ext_pause_p,c111_seq_p,ctrl_ip_50Ohms) '{
    local new_pol[]

    new_pol[0] = event_p
    new_pol[1] = ext_start_p
    new_pol[2] = ext_pause_p # not important until start using pause feature
    new_pol[3] = c111_seq_p

    if (esrf_io(DLD_DEV,"SetTfuSignalsPolarities",new_pol) < 0) {
        printf("Error setting TFU ctrl signals polarities. Giving up\n")
        return(0)
    }

    # -- 50 Ohms on TFU Control inputs
    if (esrf_io(DLD_DEV,"SetTfuInputsFiftyOhms",ctrl_ip_50Ohms) < 0) {
        printf("Error setting 50 Ohms on TFU ctrl inputs. Giving up\n")
        return(0)
    }
    return(1)
}'



#---------------------- dldsetdigin ------------------------
#%UU%
#%MDESC%
#  Set digital input configuration %BR%
#  Alternative would be to use _dld_getdigin() in the beginning instead of 
#  _dld_getstatus() and of course then DLD_DIGI_IN[] istead of DLD_STATUS[]
#
def dldsetdigin '{
    local i di_conf[] setnew

    if (!_dld_getstatus()) {
        printf("Error getting complete config+status\n")
	exit
    }
 
    setnew = 0
    for (i = 0; i < DLD_NO_CHANNELS; i++) {
        printf("Digital input %1d ",i)
        di_conf[i]   = getval(" - 50 Ohms on Digital input <0=dis/1=enab> ",\
                                  DLD_STATUS[28+i])
        if (di_conf[i] != DLD_STATUS[28+i]) setnew = 1
        di_conf[i+8] = getval("                 - GlitchFilter on Dig input<0=dis/1=enab> ", DLD_STATUS[36+i])
        if (di_conf[i+8] != DLD_STATUS[36+i]) setnew = 1
    }

    if (setnew == 1) {
        if (!_dld_setdigin(di_conf)) {
            printf("Error setting digital inputs configuration\n")
        } 
        # make next call in case dldshow is invoked immediately after
        # successfull invocation of dldsetdigin in order to get 
        # true/correct/fresh information from the hardware
        _dld_getstatus()  
    }
}'

#%IU% (digital input config array)
#%MDESC%
#  Set digital input configuration %BR%
#  First 8 fields are 50 Ohms on digital inputs enabled(1)/disabled(0)
#  Next  8 fields are glitch filter on digital inputs enabled(1)/disabled(0)
#  Return 1 on success, 0 otherwise
def _dld_setdigin(di_conf) '{
    # -- Digital inputs
    if (esrf_io(DLD_DEV,"SetDigitalInputsConfig",di_conf) < 0) {
        printf("Error setting Digital Inputs config. Giving up\n")
        return(0)
    } else {
        return(1)
    }
}'



#---------------------- dldsetanain ------------------------
#%UU%
#%MDESC%
#  Set analog input configuration %BR%
#  Alternative would be to use _dld_getanain() in the beginning instead of 
#  _dld_getstatus() and of course then DLD_ANA_IN[] instead of DLD_STATUS[]
#
def dldsetanain '{
    local i ai_conf[] setnew

    if (!_dld_getstatus()) {
        printf("Error getting complete config+status\n")
	exit
    }
 
    setnew = 0
    for (i = 0; i < DLD_NO_CHANNELS; i++) {
        printf("Analog input %1d ",i)
        ai_conf[i]    = getval(" - DigiPath on Analog input <0=dis/1=enab> ",\
                                   DLD_STATUS[44+i])
        if (ai_conf[i] != DLD_STATUS[44+i]) setnew = 1
        ai_conf[i+8]  = getval("                - Input Gain on Ana. input <0=10V/1=2.5V> ", DLD_STATUS[52+i])
        if (ai_conf[i+8] != DLD_STATUS[52+i]) setnew = 1
    }

    #printf("ai-conf array = \n")
    #print ai_conf
    #printf("dldsetanain: setnew flag = %d\n", setnew)
    if (setnew == 1) {
        if (!_dld_setanain(ai_conf)) {
            printf("Error setting analog inputs configuration\n")
        } 
        # make next call in case dldshow is invoked immediately after
        # successfull invocation of dldsetanain in order to get 
        # true/correct/fresh information from the hardware
        _dld_getstatus()  
    }
}'

#%IU% (analog input config array)
#%MDESC%
#  Set analog input configuration %BR%
#  First 8 fields are digital path on analog inputs enabled(1)/disabled(0)
#  Next  8 fields are V2F gain on analog inputs 2.5V(1)/10V(0) full scale
#  Return 1 on success, 0 otherwise
def _dld_setanain(ai_conf) '{
    if (esrf_io(DLD_DEV,"SetAnalogInputsConfig",ai_conf) < 0) {
        printf("Error setting Analog Inputs config. Giving up\n")
        return(0)
    } else {
        return(1)
    }
}'



#---------------------- DldAddConfig ---------------------------------
##
#  DldAddConfig
##
#%IU%
#%MDESC%
#  Additional config of features specific for C216, which were not 
#  in VISTA. Fix TFU frame mode always to time-frames.
#
def dldaddconfig '{
    local nl option

    if (_dld_getstatus()) {
        option= 1
        first_show = 1
        while (option) {
            # if keep this one, then cant see possible error returned
            # from macros invoked below. Therefore made one more option
            # (= option 1) to show config+status.
            ####_dld_show()
            # next one (_dld_show1()) works, but takes place
            if ((option != 1) || (first_show==1)) _dld_show1()
            if (first_show==1) first_show=0

            printf("\n\n")
            printf("(1) Show config+status\n")
            printf("(2) TFU control inputs configuration\n")
            printf("(3) Digital Inputs configuration\n")
            printf("(4) Analog Inputs configuration\n")
            printf("(0) Quit")

            option= getval("\n\n\tOption ---> ", 0)
            printf("\n\n")
            if (option==1) _dld_show()
            else if (option==2) dldsetctrlin
            else if (option==3) dldsetdigin
            else if (option==4) dldsetanain
        }
    }

}'



#---------------------- DldRunCheck (internal macro) ------------------
##
#  DldRunCheck
##
#%IU%
#%MDESC%
#  Checks if the DLD acquisition is already running (to avoid
#  starting it the second time and thus violating state machine).
#
def dldruncheck '{

  if (dld_isrunning()) {
    printf("There is a C216 acquistion running\n")
    dldstopall = yesno("Do you want to stop the current acquisition",0)
    if (dldstopall == 0) exit
    else dldstop
  }
}'



#------------------ Get_Detector_Info (internal macro) -----------------
##
#  Get_Detector_Info
##
#%IU% 
#%MDESC%
#  Fills the string DLD_DETECTORINFO
#  Called from dldinfo.
#
def get_detector_info ' {

 DLD_DETECTORINFO = "No two dim. delay line detector"
 printf("\n")

}'



#---------------------- DldMono (internal macro) ----------------
##
#  DldMono 
##
#%IU%
#%MDESC%
#  Puts the energy, sample distance and detectorposition into 
#  data collector devices created in dlddcup (called in dldsetup).
#
def dldmono '{
  local dld_egyval dld_distval

  if (USER != "opid02") {
    dld_egyval  = esrf_dc(DLD_DC_EGY,"DevRead")/1000
    dld_distval = esrf_dc(DLD_DC_SAMPLEDISTANCE,"DevRead")
    if ($# == 2 ) {
      dld_egyval  = $1
      dld_distval = $2
    } else {
      printf("Introduce values for,\n")
      dld_egyval  = getval("\tEnergy(keV):",dld_egyval)
      dld_distval = getval("\tSample distance(mm):",dld_distval)
    }

    esrf_dc(DLD_DC_EGY,"put",dld_egyval*1000)
    esrf_dc(DLD_DC_SAMPLEDISTANCE,"put",dld_distval)
    esrf_dc(DLD_DC_DETECTORPOSITION,"put",dld_distval)
  }

}'



#---------------------- DldInfo ---------------------------------
##
#  DldInfo 
##
#%UU%
#%MDESC%
#  Prompts for experiment specific parameters which are stored in the
#  header file. Must be ivoked interactively before any acquisition 
#  is done so to get useful information for the header file.
#
def dldinfo '{

  if ( $# == 0 ) {
    # get_detector_info
    DLD_PROPOSALINFO   = getval("Proposal number ",DLD_PROPOSALINFO)
    DLD_TITLE  = getval("Title",DLD_TITLE)
    DLD_EXPERIMENTINFO = getval("Experimentinfo",DLD_EXPERIMENTINFO)
    DLD_CENTER_1       = getval("Center_1 [pixel units]",DLD_CENTER_1)
    DLD_CENTER_2       = getval("Center_2 [pixel units]",DLD_CENTER_2)
    DLD_PIXSIZE_1      = 0.001*getval("Pixel Size 1 [mm]",1000*DLD_PIXSIZE_1)
    DLD_PIXSIZE_2      = 0.001*getval("Pixel Size 2 [mm]",1000*DLD_PIXSIZE_2)
    DLD_DUMMY_IN       = getval("Dummy value (Input)",DLD_DUMMY_IN)

    dldscalerassign
  }

  printf("Detector info   = %s\n",DLD_DETECTORINFO);
  printf("Proposal number = %s\n",DLD_PROPOSALINFO);
  printf("Title           = %s\n",DLD_TITLE);
  printf("Experimentinfo  = %s\n",DLD_EXPERIMENTINFO);
  printf("Center 1        = %f pixel units\n",DLD_CENTER_1);
  printf("Center 2        = %f pixel units\n",DLD_CENTER_2);
  printf("Pixel Size 1    = %f mm\n",DLD_PIXSIZE_1*1000);
  printf("Pixel Size 2    = %f mm\n",DLD_PIXSIZE_2*1000);
  printf("\n");

  dldmono

}'



#---------------------- DldGetInfo (internal macro) -------------------
##
#  DldGetInfo 
##
#%IU%
#%MDESC%
#  Reads information on some experiment related parameters
#  which are used in the header file. This macro is called
#  from dldstart. Personalize it for ID13 (it is from ID2).
#
def dldgetinfo(title) '{

  printf("\n")
  #
  #  read title  (DLD_TITLE)
  #
  if (title == "") {
    DLD_TITLE = DLD_DEFAULT_TITLE;
  } else {
    DLD_TITLE = title;
  }
  printf("  Title              = %s\n", DLD_TITLE);

  #
  # Get machine and optics information 
  #

  # made this if to work in lab.180
  if (ONBEAMLINE) {
    if (MI_PAR["BL"] == 0 || MI_PAR["BL"] == ""){
      print "You must run first \`misetup\'"
      exit
    }
    miread;
    DLD_MACHINEINFO    = sprintf(\
    "  Ie=%5.2fmA,gap46=%5.2fmm,taper46=%5.2fmm,gap26=%5.2fmm,taper26=%5.2fmm",\
    MI_PAR["CURR"],MI_PAR["GAP1"],MI_PAR["TAPER1"],\
    MI_PAR["GAP2"],MI_PAR["TAPER2"]);
    printf("%s\n", DLD_MACHINEINFO);

    DLD_STATIONINFO = sprintf("%s",MI_PAR["BL"]);
  }

  printf("  Station            = %s\n", DLD_STATIONINFO);

  #
  # Should contain slit gap info and attenuator positions
  #
  DLD_OPTICSINFO  = "optics"

  #
  # Read current wavelength (DLD_WAVELENGTH in meters from the data collector)
  #
  if (esrf_dc(DLD_DC_EGY,"DevRead") != 0) {
    DLD_WAVELENGTH = DLD_HC/esrf_dc(DLD_DC_EGY,"DevRead")*1e-9;
  } else {
    DLD_WAVELENGTH = 1
  }
  printf("  Wavelength         = %9.4g nm\n", DLD_WAVELENGTH*1e9);

  #
  # Read detector position and sample distance
  #
  DLD_DETECTORPOSITION = esrf_dc(DLD_DC_DETECTORPOSITION,"DevRead")*0.001;
  printf("  Detector position  = %9.4g mm\n", DLD_DETECTORPOSITION*1000);
  DLD_SAMPLEDISTANCE   = esrf_dc(DLD_DC_SAMPLEDISTANCE,"DevRead")*0.001;
  printf("  Sample distance    = %9.4g mm\n", DLD_SAMPLEDISTANCE*1000);

}'



#---------------------- DldScaToMem (internal macro) -------------
##
#  DldScaToMem 
##
#%IU%
#%MDESC%
#  Reads scalers data from the SSU memory(on the VISTA board) 
#  into data group DLD_GRP3.
#  There is one reading at the end of the run. 
#  
#  This macro is called from dldstop (interactive stop of the acq.)
#  and from dldstop and dldacq where acq. is stopped itself at the
#  expiration of all cycles and frames. Invoking this macro alllows
#  to have correct information on scalers content in data group 3.
# 
def dldscatomem '{
  local ret
  local i j scargout

  # first read status to find out nb of frame pairs 
  if ((stalen = esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",DLD_STATUS)) < 0) {
    printf("Error reading C216 status\n")
    exit
  }
   DLD_NO_FRAMES = DLD_STATUS[14]/2

  # +++++++++++ sleep PB 2000-04-01
  #sleep(1)
  for (i=0;i<DLD_NO_FRAMES;i++) {
  
    ret=esrf_io(DLD_DEV,"ReadScalersForOneLiveFrame",i,scargout)
    if(ret==-1) {
      printf("Error reading scalers for frame %d\n",i+1)
      exit
    }

    for(j=0;j<DLD_SCALERS;j++) {
      #if (DLD_GRP3_ON) data_put(DLD_GRP3,i,j,data_get(DLD_GRP3,i,j)+scargout[j])
      if (DLD_GRP3_ON) data_put(DLD_GRP3,i,j,scargout[j])
    }
  }

}'



#---------------------- DldScSee -----------------------------
# auxiliary macro
def dldscsee  '{

    data_dump(DLD_GRP3,0,DLD_NO_FRAMES,"all")

}'



#---------------------- DldPoll (internal macro) ----------------------
##
#  DldPoll
##
#%IU%
#%MDESC%
#  Polls the state of Dld. 
#  The while loop in this macro stops, when the acq. is over.
#
#  Refreshes SHM in the loop. Must be used interactively if dldstart
#  is used explicitely (instead of using dldacq or doing dld acquisition
#  in scan by enabling it with dldscanon). Because > 1 frame and/or > 1 cycle
#  can be used the frame and cycle number are read out and the current
#  frame data are transferred into SHM for display.
#
def dldpoll '{
 local old_cyc old_fra
 local cyc fra

 fra = 0
 old_cyc = -1
 old_fra = -1

 # prepare for cleanup
 dld_set

 # next logic is good BOTH for internal(DLD_MODE=0) as well as for
 # external(DLD_MODE=1) start
 while(1) {
   esrf_io(DLD_DEV,"tcp")
   timeout = esrf_io(DLD_DEV,"timeout",DLD_RPCTIMEOUT)
   if (dld_isrunning()) {
     #printf("TFU in C216 is waiting for ext. start or running\n")
     cyc = esrf_io(DLD_DEV,"GetTfuCurrentCycle")
     fra = (esrf_io(DLD_DEV,"GetTfuCurrentFrame"))/2
     if ((old_cyc != cyc) || (old_fra != fra)) {
       printf("Cycle %d, Frame %d    \r ",cyc,fra)
     }
     ##printf("loop counter = %d \r",loopcnt)
     old_cyc = cyc
     old_fra = fra 
   } else {
     #printf("TFU in C216 has stopped\n")
     break
   }

   sleep(2)

 } # end of while loop
  
 dld_unset

 # read scalers into data group 3 only in the end not to disturb DP
 # during the acquisition
 dldscatomem
 printf("\n")

}'



def dldcf '{
  local fra
  fra = esrf_io(DLD_DEV,"GetTfuCurrentFrame")
  printf("Current frame = %d\n", fra/2)
}'



def dld_set '{

  cdef("user_cleanup2","_dld_cleanup; ","dld")

}'



def dld_unset '{

  cdef("user_cleanup2","_dld_cleanup; ","dld", "delete")

}'



#---------------------- DldStart ---------------------------------
##
#  DldStart 
##
#%UU% [0/1(int/ext) [title-string [rel. position]]]]  
#%MDESC%
#  Triggers an acquisition.
#
#  When a parameter ( 0 or 1 ) is given the acquisition is started
#  in internal mode (0) or in external mode (1). When no parameter
#  is given the default is internal mode, without needing of external
#  trigger.
#
#  The title-string is stored by dldsave in the header file. 
#  If not specified the default given in dldinfo is used.
#  The relative position is the offset (in mm) of the sample
#  relative to the detector position. It is used to calculate
#  the sampledistance from the detector position 
#  (sample distance = detector position + relative position). 
#  The sample distance is stored by dldsave in the header file.
#  If not specified, the sample position is used that is stored 
#  in the data collector. 
#  The following additional parameters are read
#  (mainly from the datacollector):
#  machine info, station info, optics info (currently not), 
#  detector position, sample distance, start time
#  Dldconfig has to be issued first before acquisition can 
#  be started with dldstart.
#  TODO: Where is defined POINT_SKIP (also did not find it in old
#        version -> is this SPEC global??)
#  NOTE:
#        In ccd macros the start time is done in 2 steps:
#          DLD_STARTEPOCH = sprintf("%d",time());
#          DLD_STARTTIME  = sprintf("%s",date(DLD_STARTEPOCH));
#        Here, the DLD_STARTTIME which is in header file is 
#        obtained with sprintf("%d",date()); and 
#          DLD_HMSTARTTIME =  sprintf("%s",date(DLD_HMSTARTEPOCH));
#
def dldstart '{

  local ret
  local point_count point_skip

  if ($# > 3 ) {
    printf("Usage: dldstart [0(intern)/1(extern) [title [rel. position]]]\n")
    exit
  } 

  if ($# < 1) {
    DLD_MODE = DLD_INTERNAL 
  } else { 
    DLD_MODE = $1
  }

  # check the presence of beam in exp hutch
  ####beampoll

  # check that TFU in C216 is not already running
  dldruncheck

  #
  # Clear scaler group. (Re)create it.
  data_grp(DLD_GRP3,0,0)
  data_grp(DLD_GRP3,DLD_MAX_FRAME_NUMBER,DLD_SCALERS)
  DLD_GRP3_ON = 1
  #printf("After creating data group 3\n")

  #
  # Find number of frames (used later in header and in dldscatomem).
  #
  if (esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",DLD_STATUS) < 0) {
    printf("dldstart: Error reading C216 status. Giving up\n")
    exit
  } else {
    DLD_NO_FRAMES = DLD_STATUS[14]/2    # Number of frame pairs
#    printf("Nb of frames(=frame-pairs) = %d\n", DLD_NO_FRAMES)
  }

  if ((DLD_MODE!=DLD_INTERNAL) && (DLD_MODE!=DLD_EXTERNAL)) {
    print "Dld: Bad start mode"
    exit
  }

  if ($# > 1) {
    dldgetinfo("$2")	# title different from default title
  } else { 
    # dldgetinfo("")	# default title
  }

  if ($# > 2) {
     DLD_SAMPLEDISTANCE = DLD_DETECTORPOSITION+0.001*$3
  }

  # since clear with dld_clear() macro function
  startarg[1]=0
  dld_clear()
  if (DLD_MODE == DLD_INTERNAL) {    ###  Internal (default ) ###
    # get start time for header and 
    # start TFU in C216 internally
    #
    DLD_STARTTIME    = sprintf("%s",date()); # this one is in header file
    DLD_HMSTARTEPOCH = sprintf("%d",time());
    DLD_HMSTARTTIME  = sprintf("%s",date(DLD_HMSTARTEPOCH));
#    printf("  Start time         = %s\n", DLD_HMSTARTTIME);
    #printf("  Start date + time  = %s\n", DLD_STARTTIME);
    #printf("\n")
    startarg[0]=DLD_INTERNAL
    if ((ret = esrf_io(DLD_DEV,"Start",startarg)) == -1) {
      printf("Could not start C216 in internal mode\n")
      exit
    }
    #printf("OK start in internal mode\n")
  }

  if (DLD_MODE == DLD_EXTERNAL) {  ### External ###
    local _doinoldversion _dldnotrun
    #
    # start externally (i.e. wait for the external start)
    #
    startarg[0]=DLD_EXTERNAL
    if ((ret = esrf_io(DLD_DEV,"Start",startarg)) == -1) {
      printf("Could not start C216 in external mode\n")
      exit
    }
    # if want to get correct start time (= as close as possible
    # to the arrival time of external start), then must check the 
    # state to catch the transition from ON to RUNNING
    _doinoldversion = 0
    if (_doinoldversion) {
      printf("Dld: waiting for external signal to start\n")
      point_skip = 20
      point_count= 0
      _dldnotrun = 1
      while(_dldnotrun) {
        if (dld_isrunning()) {
          printf("\nDld: External start received\n")
          DLD_STARTTIME = sprintf("%s",date()); # this one is in header file
          _dldnotrun = 0
        } else {
          if (point_count==0) printf(".")
          if (point_count<POINT_SKIP) {
            point_count++
          } else {
            point_count=0
          }
          sleep(0.1)
          continue
        }
      } # end of while not running yet
    } # end of if in old version
  } # end of int/ext start case

}'



#---------------------- DldState -----------------------------
##
#  DldState
#%UU% 
#%MDESC%
#  Gives the state of TFU in C216 as TACO state string.
#
def dldstate '{

  local state_string

  state_string = esrf_io(DLD_DEV,"DevStatus")
  printf("%s\n",state_string)

}'



#---------------------- DldStatus -------------------------------
##
#  DldStatus 
##
#%UU%
#%MDESC%
#  Shows full status information
#
def dldstatus '{
 local stalen i

  if ((stalen = esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",DLD_STATUS)) < 0) {
    printf("Error reading C216 config+status\n")
    exit
  } else {
    if ($# == 0) {
      for (i=0;i<stalen;i++) {
        printf("%s : %d\n",DLD_STA_STR[i],DLD_STATUS[i])
      }
    }    
    # next flag is usefull to know when the run is over
    # (is OK for external and internal start, since is 
    # end of run (EOR) interrupt count, which is cleared
    # at start and is set to 1 at EOR
    DLD_STOPFOREXTSTART = DLD_STATUS[66];
  }

}'



#---------------------- DldStop ---------------------------------
##
#  DldStop
##
#%UU% 
#%MDESC%
#  Stops the acquisition that is currently running.
def dldstop '{
  local ret

  # - Returns state as string
  if (dld_isrunning()) {
    printf("Stopping.\n")
    ret = esrf_io(DLD_DEV,"Stop")
    if (ret < 0) {
      printf("Could not stop C216 TFU\n")
      exit
    }
  }

  # read scalers into data group 3
  dldscatomem

}'



#---------------------- DldSetTime_OLD(internal macro) --------------------
##
#  DldSetTime_OLD
##
#%IU%  live(sec) [dead(sec)]
#%MDESC%
#  Sets the live and dead time in TFG for dldacq. In this case
#  the TFG frame info file is not used, but time information
#  set with this macro (and passed through global DLD_FRAME_ARGIN)
#  is then used on dldacq.
#
#  Called from dldacq.
#
def dldsettime_OLD '{ 


  local dldacqtime dlddeadtime

  if ($# < 1) {
    p "Usage: dldsettime acqtime(in seconds) [deadtime(in seconds)]"
    exit
  }

  dldacqtime = $1
  
  if ($# > 1)  {
    dlddeadtime = $2
  } else {
    dlddeadtime = 0.006
  }

  DLD_FRAME_ARGIN[0]=1
  DLD_FRAME_ARGIN[1]=dlddeadtime
  DLD_FRAME_ARGIN[2]=1
  DLD_FRAME_ARGIN[3]=0 # continue at frame end
  DLD_FRAME_ARGIN[4]=dldacqtime
  DLD_FRAME_ARGIN[5]=1
  DLD_FRAME_ARGIN[6]=2 # stop at frame end

}'



#---------------------- DldSetTime(internal macro) --------------------
##
#  DldSetTime
##
#%IU%  live(sec) [dead(sec)]
#%MDESC%
#  Sets the live and dead time in TFG for dldacq. In this case
#  the TFG frame info file is not used, but time information
#  set with this macro (and passed through global DLD_FRAME_ARGIN)
#  is then used on dldacq.
#
#  Called from dldacq.
#
def dldsettime '{

  local dldacqtime dlddeadtime

  if ($# < 1) {
    p "Usage: dldsettime acqtime(in seconds) [deadtime(in seconds)]"
    exit
  }

  dldacqtime = $1
  
  if ($# > 1)  {
    dlddeadtime = $2
  } else {
    dlddeadtime = 0.00001
  }


  DLD_FRAME_ARGIN[0]=1
  DLD_FRAME_ARGIN[1]=dlddeadtime
  DLD_FRAME_ARGIN[2]=0
  DLD_FRAME_ARGIN[3]=0 # continue at frame end
  DLD_FRAME_ARGIN[4]=dldacqtime
  DLD_FRAME_ARGIN[5]=DLD_LIVE_OUT
  DLD_FRAME_ARGIN[6]=2 # stop at frame end

}'

def dldsetliveout '{
  if ($# == 1) {
     liveout = $1
  } else {
     liveout = 0
  }
  if ((liveout < 0) || (liveout > 255)) {
     p "Usage: dldsetliveout liveout(0->255)"
     exit
  }
  DLD_LIVE_OUT = liveout
}'


#---------------------- DldAcq ---------------------------------
##
#  DldAcq
##
#%UU% acqtime(sec) [deadtime(sec)]
#%MDESC%
#  Do an acquisition on Dld for acqtime seconds on live.
#  Single frame, single cycle. 
#  Internal start is used.
#
def dldmenu '{
global TFG_TRIG
TFG_TRIG=yesno("Trigger TFG externally", TFG_TRIG)
}'

def dldacq '{
local save_data

  if ($# < 1) {
    p "Usage: dldacq acqtime(in seconds) [deadtime(in seconds) [<title>]]"
    exit
  }
  #
  #  First configure
  #
  if ($# < 2) {dldsettime  $1 } else { dldsettime  $1 $2 }

  if ($# < 3) { save_data = 0 } else { save_data = 1 }

  if (!save_data) {
    printf(" The data will not be saved. Use dldsave to save them or \n");
    printf(" supply a title next time ");
    }

  DLD_NO_CYCLES = 1
  dldnocycles
  dldconfigall "nofile"

  #
  if ($# < 3) {
    if (TFG_TRIG) { dldstart 1 } else { dldstart 0 }
  } else {
    if (TFG_TRIG) { dldstart 1 "$3"} else { dldstart 0 "$3"}
  }

  # poll the state to see when the acq. is over.
  # In the end also read scalers into the data group 3.
  # Reading of scalers is done only in the end after the
  # acq. is over not to disturb it.
  sleep(1)
  #print "Before dldpoll"
  dldpoll
  #print "After dldpoll"
  dldsum
  sleep(1)
  if (save_data) {
    dldsave 
    sleep(1)
  } else {
    printf("\n\n ---- Data not saved ---- \n\n");
  }

}'



#---------------------- DldSave ---------------------------------
##
# DldSave
##
#%UU%  
#%MDESC%
#  Dumps the 16 scalers into a file. The name of the file is formed with the
#  prefix given in the configuration plus a three number suffix (run number)
#  starting with 001. This number is automatically incremented. The full name
#  of the file is echoed to the user. This macro is automatically called
#  only in dld_loop (when dld acq. is done during scan). 
#
def dldsave '{

  local first_scalerno last_scalerno
  local first_frameno last_frameno scaler_size
  local header_length
  local dld_deltatime
  local i j

  if ($# > 0 ) {
    print "Usage: dldsave"
    exit
  }

  DLD_HEADER_FILE=sprintf("%s/%s%.3d",DLD_DATA_DIR,DLD_FILE_PREFIX,++DLD_RUN_NUMBER)
  
  printf("Transferring Dld data\n")
  printf("\tHeader file:  %s\n",DLD_HEADER_FILE)
  # ***************************************
  #
  # Write header file.
  #
  # ***************************************

  if (unix(sprintf("test -f %s\n",DLD_HEADER_FILE)) == 0) {
    printf("File %s exists\n",DLD_HEADER_FILE)
    print "Choose another name"
    exit
  } else {
    unix(sprintf("touch %s\n",DLD_HEADER_FILE))
  }

  #
  # -- TOP HEADER
  #
  on(DLD_HEADER_FILE);offt
  print 4                    # length of top header (separator included)
  print DLD_RUN_NUMBER       # run number
  print "2.2"                # header and data version 2.2 
  print DLD_SEPARATOR
  ont;close(DLD_HEADER_FILE)

  #
  # -- SCALER HEADER
  #
  if (esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",DLD_STATUS) < 0) {
    printf("Error reading C216 config+status\n")
    on(DLD_HEADER_FILE);offt
    print "Error getting status from C216 device server. Wont transfer any data"
    ont;close(DLD_HEADER_FILE)
    exit
  }
  first_scalerno = 1
  # later should set last_scalerno = DLD_SCALERS
  last_scalerno  = DLD_SCALERS
  first_frameno  = 1
  last_frameno   = DLD_STATUS[14]/2
  scaler_size=(last_scalerno-first_scalerno+1)*(last_frameno-first_frameno+1)*4
  header_length  = 10

  on(DLD_HEADER_FILE);offt
  print header_length  #  Length of scaler header (separator included) 
  print 2              #  Scaler header ID
  print first_scalerno #  first scaler number (1 <= x <= 16)
  print last_scalerno  #  last scaler number (1 <= x <= 16)
  print first_frameno  #  first frame number
  print last_frameno   #  last frame number
  print 0              #
  print 0              #
  print scaler_size    #  Length of scaler memory in bytes
  print DLD_SEPARATOR
  ont;close(DLD_HEADER_FILE)

  #
  # -- SCALER DATA
  #
  header_length  = (last_frameno - first_frameno + 1) * (last_scalerno - \
                     first_scalerno + 1) + 3 


  on(DLD_HEADER_FILE);offt
  print header_length  #  Length of header
  print 5              #  Scaler data ID
#  for (i=first_scalerno-1;i<last_scalerno;i++) {#}
#    for (j=first_frameno-1;j<last_frameno;j++) {#}
  for (j=first_frameno-1;j<last_frameno;j++) {
    for (i=first_scalerno-1;i<last_scalerno;i++) {
      print data_get(DLD_GRP3,j,i)
    }
  }
  print DLD_SEPARATOR
  ont;close(DLD_HEADER_FILE)

  #
  # -- IMAGE HEADER (makes no sense with C216, but keep it for PB)
  #
  on(DLD_HEADER_FILE);offt
  print 12               # Length of header
  print 3                # HM Id
  print 32               # Data length (16/32 bits)
  print 512              # Dim_1 Resolution in x
  print 512              # Dim_2 Resolution in y
  print DLD_STATUS[14]/2 # Total number of frames
  print 0                # resolution mode
  print 0
  print 0                # Length of HM in bytes (=effective partition size)
  print 0                # Offset_1  (must be 0 or positive)
  print 0                # Offset_2  (must be 0 or positive)
  print DLD_SEPARATOR
  ont;close(DLD_HEADER_FILE)

  #
  # --- TIMING HEADER
  #
  first_frameno = 1;
  last_frameno = DLD_STATUS[14]/2;
  header_length = 4+last_frameno-first_frameno+1;

  on(DLD_HEADER_FILE);offt
  print header_length    # Length of header
  print "TIMING"         # Timing ID
  print DLD_STARTTIME    # Start time of acquisition
  dld_deltatime = 0;     # Start time of life frame since DLD_STARTTIME
  for (i=first_frameno, k=0;i<=last_frameno;i++) {
    dld_deltatime = dld_deltatime + DLD_FRAME_INFO[k++]
    print dld_deltatime;
    dld_deltatime = dld_deltatime + DLD_FRAME_INFO[k++]
  }
  print DLD_SEPARATOR
  ont;close(DLD_HEADER_FILE)

  #
  # --- SCALER CALIBRATION HEADER
  #
  header_length = 10+3*(last_scalerno-first_scalerno+1)+4

  on(DLD_HEADER_FILE);offt
  print header_length
  print "SCALERCALIB"        #
  print 32	             # DLD_SCALER_DEPTH (valid bits of scaler data)
  print DLD_SCALER_I0        # scaler number for incident number of photons
  print DLD_SCALER_I1        # scaler number for transmitted number of photons
  print DLD_SCALER_ANODE     # scaler number for anode counts
  print DLD_SCALER_TIME      # scaler number for exposure time
  print first_scalerno
  print last_scalerno
  for (i=first_scalerno-1;i<last_scalerno;i++) {
    print DLD_SCALER_NAME[i];
    print DLD_SCALER_ZERO[i];
    print DLD_SCALER_CALIB[i];
  }
  print 0 # DLD_SCALER_I0S (2nd scaler nb for incident nb of photons)
  print 0 # DLD_SCALER_I1S (2nd scaler nb for transmitted nb of photons)
  print 0 # DLD_SCALER_ANODES (2nd scaler nb for anode counts)
  print 0 # DLD_SCALER_TIMES  (2nd scaler nb for exposure time)
  print DLD_SEPARATOR
  ont;close(DLD_HEADER_FILE)

  #
  # --- EXPERIMENT HEADER
  #
  on(DLD_HEADER_FILE);offt
  print 12                   # header length
  print "EXPERIMENT"         # experiment header ID
  print DLD_CENTER_1         # beam center in direction 1 (pixel units)
  print DLD_CENTER_2         # beam center in direction 2 (pixel units)
  print DLD_PIXSIZE_1        # pixel size in direction 1 (meters)
  print DLD_PIXSIZE_2        # pixel size in direction 2 (meters)
  print DLD_WAVELENGTH       # wavelength (meters)
  print DLD_SAMPLEDISTANCE   # distance between sample and detector (meters)
  print DLD_TITLE            # user supplied title
  print DLD_EXPERIMENTINFO   # user supplied name of the sample etc.
  print DLD_DETECTORPOSITION # position of the detector (meters)
  print DLD_SEPARATOR

  #
  # --- INFO HEADER
  #
  print 8                    # header length
  print "INFO"               # info header ID
  print DLD_DETECTORINFO     # detector info 
  print DLD_MACHINEINFO      # machine info
  print DLD_OPTICSINFO       # optics info
  print DLD_STATIONINFO      # name of the station
  print DLD_PROPOSALINFO     # proposal number and info
  print DLD_SEPARATOR
  ont;close(DLD_HEADER_FILE)

  # ***************************************
  #
  # Save ehf header file.
  #
  # ***************************************

   printf("\tEhf file:  %s.ehf\n",DLD_HEADER_FILE)

   edf_save_id02 DLD_HEADER_FILE 1

}'



# ------------------------------------------------------------
#
# From here on are scaler related macros 
#
# First the important ones (dldsum, dldscalerzero, dldscalercalib ...)
# which concern a group of scalers and header information.
#
#------------------ DldScalerValue() (internal macro function) ------------
##
# DldScalerValue
##
#%UI% scaler, time_value, frameno, datagroup
#%MDESC%
#  return current scaler value (normalized with zero and calib)
#  This macro function is adapted from dldcountervalue() of ID1
#  differences:
#   - names chage:
# 	DLD_COUNTER_ZERO  -> DLD_SCALER_ZERO
#	DLD_COUNTER_CALIB -> DLD_SCALER_CALIB
#   - 2 more arguments: frameno, datagroup 
#
def dldscalervalue ( scaler, time_value, frameno, datagroup ) '{

  local i;
  local counts zero calib value;

  if (scaler=="?") {
     printf("dldscalervalue ( scaler, time_value, frameno, datagroup )\n"); exit;
  }

  #printf("Time value = %g\n", time_value)
  if ((1<=scaler)&&(scaler<=DLD_SCALERS)) {
    i = scaler - 1;
    counts = data_get(datagroup,frameno-1,i)
    zero   = DLD_SCALER_ZERO[i];	# rate
    calib  = DLD_SCALER_CALIB[i]; 
    value  = (counts-(zero*time_value))*calib;
    #printf("Frame = %d, scaler = %d, value = %g\n",frameno,scaler,value)
  } else {
    printf("Undefined scaler number %d\n",scaler);
    value = 0.0;
  }

  return( value );
 
}'



#---------------------- DldSum -------------------------------
##
# DldSum
##
#%UU% [frame-no] 
#%MDESC%
#  Displays the anode counts, the number of incident
#  and transmitted photons and the counting time. 
#
#  This macro is not called from any other and is meant for 
#  interactive use, but macro function dld_resume(), which is 
#  called in it is also callled in dldacq and in dld_poll.
#
#  The following macros must be called before using this one:
#  dldscalersetup, dldscalerassign, dldscalerzero(acq. with shutter closed),
#  dldacq, dldscalercalib
#
def dldsum '{

  local no_frames frameno

  if ($# > 1 ) {
    print "Usage: dldsum [frame-no(1 ->tot.frames)]"
    exit
  }

  # 
  # Get DLD status
  #
  if (esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",DLD_STATUS) < 0) {
    printf("ERROR : Cannot read C216 status\n")
    exit
  } 
  no_frames = DLD_STATUS[14]/2     # should be equal to DLD_NO_FRAMES 
 
  #
  # Read frame number 
  #
  if ($#)  frameno = $1;
  else frameno = no_frames;

  if ((frameno>no_frames)||(frameno<1)) {
    printf("ERROR : Frame number %d does not exist\n",frameno);exit;
  }
  
  dld_resume(frameno)

}'



#------------------ Dld_Resume() (internal macro function) ----------------
##
#  Dld_Resume (adapted from ID1, but dropped scaler nb args and added arg=frameno)
##
#%IU% frameno
#%MDESC%
#  Displays the anode counts, the number of incident
#  and transmitted photons and the counting time.
#  (dld scaler numbers are from 1 to DLD_SCALERS, instead 0 to DLD_SCALERS-1)
#  frameno      : frame number (in range [1,DLD_NO_FRAMES]) 
#  DLD_SCALER_TIME   number of the exposure time scaler
#  DLD_SCALER_ANODE  number of the anode counts scaler
#  DLD_SCALER_I0     number of the I0 monitor scaler (before sample)
#  DLD_SCALER_I1     number of the I1 monitor scaler (after sample)
#  The units of DLD_SCALER_I0 and DLD_SCALER_I1 should be photons
#
def dld_resume (frameno) '{

  dldscatomem

  # may be later change to a bigger number
  DLD_EPS=1e-30

  local time_value anode_value i0_value i1_value trm_value

  # following are corrected values (zero subtracted and multiplied by calib.factor)
  time_value  = dldscalervalue(DLD_SCALER_TIME , 0.0, frameno, DLD_GRP3);
  if (DLD_SCALER_ANODE>0)
    anode_value = dldscalervalue(DLD_SCALER_ANODE, time_value, frameno, DLD_GRP3);
  i0_value    = dldscalervalue(DLD_SCALER_I0, time_value, frameno, DLD_GRP3);
  i1_value    = dldscalervalue(DLD_SCALER_I1, time_value, frameno, DLD_GRP3);
  # Calculate transmission
  if(fabs(i0_value)>DLD_EPS) trm_value = i1_value/i0_value
  else trm_value = 0.0

  # The following global variables are used in the ehf header
  DLD_EXPOSURETIME = time_value
  DLD_ANODECOUNTS  = anode_value
  DLD_I0           = i0_value
  DLD_I1           = i1_value

  #---------
  # write out on screen
  #
  if (DLD_SCALER_ANODE>0)
    printf("  Number of anode counts (%10s)              = %9.3g \n",\
     DLD_SCALER_NAME[DLD_SCALER_ANODE-1], int(anode_value));
  printf("  Counting time (%10s)                       = %9.3g s\n",\
   DLD_SCALER_NAME[DLD_SCALER_TIME-1], time_value);
  printf("  Transmission (%10s/%10s)             = %9.3g\n",\
   DLD_SCALER_NAME[DLD_SCALER_I1-1],DLD_SCALER_NAME[DLD_SCALER_I0-1],trm_value);
  printf("  Total number of incident photons (%10s)    = %9.3g ph\n",\
   DLD_SCALER_NAME[DLD_SCALER_I0-1], i0_value);
  printf("  Total number of transmitted photons (%10s) = %9.3g ph\n",\
   DLD_SCALER_NAME[DLD_SCALER_I1-1], i1_value);

}'



#---------------------- DldScalerSetup --------------------------------
##
# DldScalerSetup 
##
#%UU%
#%MDESC%
#  Macro that allows the user to give the following information
#  for ONE scaler where scaler number can be [1,DLD_SCALERS]:
#  - scaler name
#  - 'zero' value = count rate measured with shutter closed 
#  - calib  value = count rate with respect to a reference scaler
#
#  To really get correct values for 'zero' count rate and 
#  for the calibration factor, must use macros dldsczero
#  and dldsccalib (see further down).
#  Note: I changed the order of parameters, since name was in the 
#        end before (sounds more logical to put it after scaler 
#        number as second argument). On ID1 this was not important,
#        since the counters were in spec config and their names
#        were obtained by cnt_name().
#
def dldscalersetup '{

  local zero calib name x
  local scaler

  if (($#>0)&&($#!=4)&&($#!=5)&&($#!=6)) {
    printf(\
      "Usage: dldscalersetup <scaler> <name> <zero> <calib> [<x> [<gain>]]\n")
    exit
  }

  if ($# > 0 ) {
    scaler = $1;
  } else {
    scaler = getval("Scaler number ", scaler);
  }
  if ((scaler>=1) && (scaler<=DLD_SCALERS)) {
    if ($# > 1) DLD_SCALER_NAME[scaler-1]  = "$2";
    else DLD_SCALER_NAME[scaler-1] = \
      getval("Scaler name                         ",DLD_SCALER_NAME[scaler-1]);
    if ($# > 2) DLD_SCALER_ZERO[scaler-1]  =  $3;
    else DLD_SCALER_ZERO[scaler-1] = \
      getval(sprintf("  Zero value of %10s (ct/s)       ",\
        DLD_SCALER_NAME[scaler-1]),DLD_SCALER_ZERO[scaler-1])
    if ($# > 3) DLD_SCALER_CALIB[scaler-1]  = $4;
    else DLD_SCALER_CALIB[scaler-1] = \
      getval(sprintf("  Calibration factor of %10s      ",\
        DLD_SCALER_NAME[scaler-1]),DLD_SCALER_CALIB[scaler-1])
    if ($# > 4) DLD_SCALER_X[scaler-1]  = $5;
    else DLD_SCALER_X[scaler-1] = 1 # default is yes
    if ($# > 5)
      if (whatis("DLD_SCALER_GAIN")&0x01000000) DLD_SCALER_GAIN[scaler-1] = $6;
  } else {
    printf("Bad scaler number; should be [1,%d]\n", SCALERS)
  }
  if (whatis("ID2HEADER_SCALER_SETUP_TIME"))
    ID2HEADER_SCALER_SETUP_TIME = ""  # Unknown scaler setup status 
  if (whatis("id2headervfclistupdate")&2) eval("id2headervfclistupdate()")
}'



#---------------------- DldScalerSetupSave ----------------------------
##
# DldScalerSetupSave
##
# (originally this macro had name dldsave) 
# N.B. Peter said it is not used
##
#%UU% [filename]
#%MDESC%
#  Save setup values for DLD_SCALERS (this is set to 16) scalers.
#  Takes filename as input. But only considered the string until the
#  first dot. Completes the name with suffix dld.
#  File is saved in directory ~specadm/local/userconf.
#
def dldscalersetupsave '{

  local dldarr

  if ($# == 0 ) {
    fileroot = getval("Save current scaler setup under which name","")
  }  else {
    fileroot = "$1"
  }
  split(fileroot,dldarr,".")
  fileroot = dldarr[0]
    
  filename = sprintf("%s/../local/userconf/%s.dld",SPECD,fileroot)

  on(filename);offt
  for (i=0;i<DLD_SCALERS;i++) {
    if (DLD_SCALER_NAME[i] != "") {
      printf("DLD_SCALER_NAME[%d]=\"%s\"\n",i,DLD_SCALER_NAME[i])
    }
    printf("DLD_SCALER_ZERO[%d]=%g\n",i,DLD_SCALER_ZERO[i])
    printf("DLD_SCALER_CALIB[%d]=%g\n",i,DLD_SCALER_CALIB[i])
    # do not have to save DLD_SCALER_X[i]
  }
  ont;close(filename)

  printf("\nOk. Current scaler setup saved with name \"%s\"\n",fileroot)
  printf("Use dldscalersetuprestore \"%s\" to restore\n",fileroot)

}'



#---------------------- DldScalerSetupRestore -------------------------
##
# DldScalerSetupRestore 
##
# (originally this macro had name dldrestore) 
# N.B. Peter said it is not used
##
#%UU% [filename]
#%MDESC%
#  Restore scaler setup values from a previous dldscalersavesetup.
#  Takes filename as input. But only considered the string until the
#  first dot. Completes the name with suffix dld.
#
def dldscalersetuprestore '{

  local dldarr fileroot

  if ($# == 0 ) {
    unix(sprintf("cd %s/../local/userconf;ls *.dld",SPECD))
    fileroot = getval("\nSelect file to restore","")
  }  else {
    fileroot = "$1"
  }

  split(fileroot,dldarr,".")
  fileroot = dldarr[0]
    
  filename = sprintf("%s/../local/userconf/%s.dld",SPECD,fileroot)

  qdofile(filename)

  printf("\nOk. Done\n")

}'



#---------------------- DldScalerSetupShow -------------------------
##
# DldScalerSetupShow 
##
# (originally this macro had name dldwatchscalersetup on ID2
#                             and dldwatchsetup on ID1)  
#%UU%  
#%MDESC%
#  Displays the zero values and calibration values of all scalers.
#  This information is introduced with dldscalersetup
#
# def wss 'dldscalersetupshow' # This is done in ID2alias.mac

def dldscalersetupshow '{

  printf("Shows dld scaler calibration setup\n")
  printf("----------------------------------\n")
  printf("Scaler depth %d (number,name,zero,calib)\n",\
           DLD_HMSCALER_DEPTH)

  for (i = 0,k = DLD_SCALERS; i < k;i+=8) {
    for (j=0;j<8;j++) {
      printf("Scaler %2d ",i+j+1)
    }
    printf("\n")
    for (j=0;j<8;j++) {
      printf("%9s ",DLD_SCALER_NAME[i+j])
    }
    printf("\n")
    for (j=0;j<8;j++) {
      printf("%9.3g ",DLD_SCALER_ZERO[i+j])
    }
    printf("\n")
    for (j=0;j<8;j++) {
      printf("%9.3g ",DLD_SCALER_CALIB[i+j])
    }
    printf("\n")
    if (i<k-8) printf("\n");
  }

}'



#---------------------- DldScalerAssign -------------------------
##
# DldScalerAssign 
##
#%UU% i0-scaler i1-scaler time-scaler anode-scaler 
#%MDESC%
#  Assignment of a scaler as monitor
#  for incident photons (i0), transmitted photons (i1), 
#      time (time) and anode counts (anode).
#  The scaler range is [1,DLD_SCALERS].
#
def dldscalerassign '{

  if ($# != 0 && $# != 4) {
    printf(" Usage: dldscalerassign <i0_scaler> <i1_scaler> <time_scaler> <anode_scaler>\n");
    exit
  }  
   
  if ($# == 0 ) {
    if ((DLD_SCALER_I0<1) || (DLD_SCALER_I0>DLD_SCALERS)) DLD_SCALER_I0=5
    DLD_SCALER_I0    = getval(sprintf("Scaler for incident photons (%s)", \
        DLD_SCALER_NAME[DLD_SCALER_I0-1]), DLD_SCALER_I0)
    if ((DLD_SCALER_I1<1) || (DLD_SCALER_I1>DLD_SCALERS)) DLD_SCALER_I1=8
    DLD_SCALER_I1    = getval(sprintf("Scaler for transmitted photons (%s)", \
        DLD_SCALER_NAME[DLD_SCALER_I1-1]), DLD_SCALER_I1)
    if ((DLD_SCALER_TIME<1) || (DLD_SCALER_TIME>DLD_SCALERS)) DLD_SCALER_TIME=15
    DLD_SCALER_TIME  = getval(sprintf("Scaler for exposure time (%s)", \
        DLD_SCALER_NAME[DLD_SCALER_TIME-1]), DLD_SCALER_TIME)
    if ((DLD_SCALER_ANODE<1) || (DLD_SCALER_ANODE>SCALER)) DLD_SCALER_ANODE=13
    DLD_SCALER_ANODE = getval(sprintf("Scaler for anode counts (%s)", \
        DLD_SCALER_NAME[DLD_SCALER_ANODE-1]), DLD_SCALER_ANODE)
  } else {
    DLD_SCALER_I0      = $1
    DLD_SCALER_I1      = $2
    DLD_SCALER_TIME    = $3
    DLD_SCALER_ANODE   = $4
  }
  if (DLD_SCALER_DEPTH == 0 ) DLD_SCALER_DEPTH = 32 

  DLD_I0_MONITOR           = sprintf("%s",DLD_SCALER_NAME[DLD_SCALER_I0-1]); 
  DLD_I1_MONITOR           = sprintf("%s",DLD_SCALER_NAME[DLD_SCALER_I1-1]);
  DLD_ANODECOUNTS_MONITOR  = sprintf("%s",DLD_SCALER_NAME[DLD_SCALER_ANODE-1]);
  DLD_EXPOSURETIME_MONITOR = sprintf("%s",DLD_SCALER_NAME[DLD_SCALER_TIME-1]);

  dldscalerassignshow

}'



#---------------------- DldScalerAssignShow ----------------------
##
# DldScalerAssignShow 
# On ID1 this macro has name listdldcounters 
##
#%UU%
#%MDESC%
#  Shows on the screen the scaler assignment configuration
#  defined by macro dldscassign. 
#  This macro is called from dldscassing but can be used
#  also interactively.  
#
# def wsa 'dldscalerassignshow;dldscalerlist' # must be done in ID2alias.mac

def dldscalerlist '{
  printf("Current dld scaler configuration/assignment:\n");
  printf("\n");
  printf("%10s  %20s\n","Dld num","scaler name");
  printf("\n");
     
  for (i=0 ; i<DLD_SCALERS; i++) {
    printf("%10d  %20s",i+1,DLD_SCALER_NAME[i]);
    #if (DLD_SCALER_X[i]) printf(" (ZERO calibration) ");
    #                else printf(" ------------------ ");
    printf(" (ZERO calibration) ");
    if ((i+1) == DLD_SCALER_TIME) printf(" <- exposure time" )
    if ((i+1) == DLD_SCALER_ANODE) printf(" <- anode" )
    if ((i+1) == DLD_SCALER_I0) printf(" <- i0" )
    if ((i+1) == DLD_SCALER_I1) printf(" <- i1" )
    printf("\n");
  }
  printf("\n");

}'


def dldscalerassignshow '{
  local oldway

  oldway = 1
  if (oldway) {
    printf("\n");
    printf("Scaler for incident photons (%9s)          = %d\n", \
      DLD_SCALER_NAME[DLD_SCALER_I0-1], DLD_SCALER_I0)
    printf("Scaler for transmitted photons (%9s)       = %d\n", \
      DLD_SCALER_NAME[DLD_SCALER_I1-1], DLD_SCALER_I1)
    printf("Scaler for exposure time (%9s)             = %d\n", \
      DLD_SCALER_NAME[DLD_SCALER_TIME-1], DLD_SCALER_TIME)
    printf("Scaler for anode counts (%9s)              = %d\n", \
      DLD_SCALER_NAME[DLD_SCALER_ANODE-1], DLD_SCALER_ANODE)
  }

}'



#---------------------- Min and Max internal macro functions -----------------
def min ( a, b ) '{ return((a<b)?a:b) }'
def max ( a, b ) '{ return((a>b)?a:b) }'



#---------------------- DldScalerDump (internal macro function) --------------
##
# DldScalerDump 
# On ID1 it is called dldcounterdump
##
#%IU% first, last
#%MDESC%
#  List setup of all dld scalers. The list can afterwards be reloaded.
#
def dldscalerdump ( first, last ) '{

  local i;

  if (first=="?") { printf("dldscalerdump ( first, last )\n");
     exit; }

  first = max(1,min(first,DLD_SCALERS));
  last  = max(1,min(last,DLD_SCALERS));

  # Update scalers if id2headerscalerupdate is a macro
  if (whatis("id2headerscalerupdate")&2) eval("id2headerscalerupdate()")

  print("# " date());
  for (i = first ; i<=last ; i++ ) {
    #printf("dldscalersetup ( %d, \"%s\",%g, %g, %d );\n",\
    #    i,DLD_SCALER_NAME[i-1],DLD_SCALER_ZERO[i-1],DLD_SCALER_CALIB[i-1],\
    #    DLD_SCALER_X[i-1]);
    if (whatis(sprintf("DLD_SCALER_GAIN[%d]",i-1))&0x80000000) {
      printf("dldscalersetup %d \"%s\" %g %g%s%s\n",\
        i,DLD_SCALER_NAME[i-1],DLD_SCALER_ZERO[i-1],DLD_SCALER_CALIB[i-1],\
        (DLD_SCALER_X[i-1]!=1)?" 0":" 1",\
        (DLD_SCALER_GAIN[i-1]>0)?sprintf(" %d",DLD_SCALER_GAIN[i-1]):"" )
    } else { printf("dldscalersetup %d \"%s\" %g %g%s\n",\
      i,DLD_SCALER_NAME[i-1],DLD_SCALER_ZERO[i-1],DLD_SCALER_CALIB[i-1],\
      (DLD_SCALER_X[i-1]!=1)?" 0":"")
    }
  }

  printf("dldscalerassign %d %d %d %d \n",\
   DLD_SCALER_I0, DLD_SCALER_I1, DLD_SCALER_TIME, DLD_SCALER_ANODE );

}'



#---------------------- DldDump -------------------------
##
# DldDump 
##
#%UU% dlddump [ <output file> ]
#%MDESC%
# List the setup of all dld scalers on terminal or save it to a file.
# The file can be used to reload the setup with qdo <filename>
#
def dlddump '{
  if ($#>1) {
    printf(" dlddump [<output file>]\n"); exit;
  }

  if ($#==1) {
    on("$1");offt;
    dldscalerdump(1,DLD_SCALERS);
    ont;off("$1");
    close("$1");
  } else dldscalerdump(1,DLD_SCALERS);
}'


 
#---------------------- OldScalerDump -------------------------
##
# OldScalerDump (old scaler dump) 
##
#%UU% oldscalerdump [<startno> [<endno>]]
#%MDESC%
#  Prints on screen scalers setup and assignments.
#  It shows this in the form of command + params used 
#  to setup (1 line/scaler) and assign scalers, but 
#  does not execute these commands since they are just 
#  in printf statement.
#  More detailed information about scaler setup and 
#  assignments can be obtained by using macros:
#  dldscsalersetupshow (briefly wss) and
#  dldscalerassignshow(briefly wsa).
#
def oldscalerdump '{

  local fst_scaler lst_scaler i

  if (($# < 0 ) || ($#>2)) {
    printf("Usage: oldscalerdump [fst_scaler [lst_scaler]]\n")
    exit
  }
  fst_scaler = 1
  lst_scaler = DLD_SCALERS 

  if ($# > 0) {
    fst_scaler = $1
    lst_scaler = $1
  }
  if ($# > 1) lst_scaler = $2

  if (fst_scaler < 1) fst_scaler = 1
  if (lst_scaler > DLD_SCALERS) lst_scaler = DLD_SCALERS 

  print("# " date());
  for (i = fst_scaler-1 ;i < lst_scaler;i++ ) {
    #printf("dldscalersetup %d %s %g %g %d\"%s\";\n",\
    #  i+1,DLD_SCALER_NAME[i],DLD_SCALER_ZERO[i],DLD_SCALER_CALIB[i],DLD_SCALER_X[i]);
    printf("dldscalersetup %d %s %g %g \"%s\";\n",\
      i+1,DLD_SCALER_NAME[i],DLD_SCALER_ZERO[i],DLD_SCALER_CALIB[i]);
  }

  printf("dldscalerassign %d %d %d %d ;\n",\
    DLD_SCALER_I0, DLD_SCALER_I1, DLD_SCALER_TIME, DLD_SCALER_ANODE);

}' 



#---------------------- DldWatchScalers -------------------------
##
# DldWatchScalers
# (On ID1 called dldwatchcounters)
##
#%UU% [frame-no] 
#%MDESC%
#  Macro to show for all DLD_SCALERS scalers the following values:
#  - scaler nb,
#  - scaler name, 
#  - scaler raw value,
#  - scaler corrected value.
#
#  The corrected value is the value from which the background
#  (value i.e. the value acquired with shutter closed) is
#  subtracted and corrected for the calibration factor.
#
#def ws 'dldwatchscalers' # must be done in ID2alias.mac

def dldwatchscalers '{

  local time_value
  local frameno 

  dldscatomem

  if($#) frameno = $1
  else frameno = DLD_NO_FRAMES

  if ((frameno < 1) || (frameno > DLD_NO_FRAMES)) {
    printf("\nYou selected NONEXISTENT (%d) frame !!!, Should be [1,%d]\n",\
           frameno, DLD_NO_FRAMES)
    printf("Will display scalers data for THE LAST frame (%d)\n", DLD_NO_FRAMES)
    printf("\n") 
    frameno = DLD_NO_FRAMES
  }

  time_value = dldscalervalue(DLD_SCALER_TIME , 0.0, frameno, DLD_GRP3);

  printf("Watch Dld scaler values: Usage ws [frame]\n")
  printf("----------------------------------------------\n")
  printf("Frame %d: Scaler (number,name,counts,value), counting time %g\n",frameno, time_value)


  for (i = 0,k = DLD_SCALERS; i < k;i+=8) {
    for (j=0;j<8;j++) {
      printf("scaler %2d ",i+j+1)
    }
    printf("\n")
    for (j=0;j<8;j++) {
      printf("%9s ",DLD_SCALER_NAME[i+j])
    }
    printf("\n")
    for (j=0;j<8;j++) {
      printf("%9.3g ",data_get(DLD_GRP3,frameno-1,i+j))
    }
    printf("\n")
    for (j=0;j<8;j++) {
      printf("%9.3g ",dldscalervalue(i+j+1,time_value,frameno,DLD_GRP3))
    }
    printf("\n")
    if (i<k-8) printf("\n");
  }

}'



#---------------------- DldScalerZero -------------------------
##
# DldScalerZero 
##
#%UU% dldscalerzero count-time [fst_scaler [lst_scaler]] 
#%MDESC%
#  Measure the count rate with the shutter closed in order
#  to fill the DLD_SCALER_ZERO array. This value multiplied
#  by the counting time is then subtracted from the raw
#  scaler counts to correct for background. 
# 
#  The scaler range is [fst_scaler, lst_scaler].
#  This is done only for selected scalers which have
#  DLD_SCALER_X flag set to 1.
#
def dldscalerzero '{

  local _bidon
  local fst_scaler lst_scaler
  local wanted_ctime rounded_ctime

  if (($# < 1 ) || ($#>3)) {
    printf("dldscalerzero count-time [fst_scaler [lst_scaler]]\n")
    exit
  }

##  if ($# == 3) {
    _bidon = yesno("Is your frontend beamshutter closed",1)
    if (!_bidon) exit 
##  }

  fst_scaler = 1; lst_scaler = DLD_SCALERS 

  if ($# > 0) wanted_ctime = $1
  if ($# > 1) {fst_scaler = $2; lst_scaler = $2;}
  if ($# > 2) {lst_scaler = $3 } else { lst_scaler = 14 }

  if (fst_scaler<1)      fst_scaler=1
  if (lst_scaler>DLD_SCALERS)  lst_scaler=DLD_SCALERS

  printf("  wanted counting time  : %f\n", wanted_ctime)
  printf("  selected scalers range: %d .. %d\n", fst_scaler, lst_scaler)
  #
  # Now prepare argin. Only one time frame pair is used.
  #
  DLD_FRAME_ARGIN[0]=1 
  DLD_FRAME_ARGIN[1]=0.01
  DLD_FRAME_ARGIN[2]=0		# no output during DEAD 
  DLD_FRAME_ARGIN[3]=0		# continue 
  DLD_FRAME_ARGIN[4]=wanted_ctime
  DLD_FRAME_ARGIN[5]=0		# no output during LIVE
  DLD_FRAME_ARGIN[6]=2 		# stop at frame end 

  #
  # configure the h/w. The programmed values in TFG 
  # are echoed (printed in the end of dldconfigall).
  #
  dldconfigall "nofile"

  rounded_ctime = DLD_FRAME_INFO[1]
  # Remark: The total counting time is based on effective
  #         length of TFG live frame.
  #         Here the scaler used for the time is not used
  #         This scaler is defined in dldscalerassign.
  #         Alternative for getting total counting time 
  #         would be to read the contents of the time scaler.
  #
  printf(" rounded counting time: %f\n",rounded_ctime)
  printf("  selected scalers range: %d .. %d\n", fst_scaler, lst_scaler)
  #
  # Starts the acquisition for live_time.
  #
  dldstart 0
  sleep(0.1) 
  # poll to see the end of the acq. + refresh SHM for display
  # In the end when the acq. is over read sclers into data group 3.
  # Do this only after the acq. not to disturb DP during the acq.
  dldpoll 

  #
  # Then set the variable DLD_SCALER_ZERO equal to COUNT/TOTAL_TIME
  # 
  for (i = fst_scaler-1 ; i<lst_scaler ; i++ ) {
    #if(DLD_SCALER_X[i]) {
      DLD_SCALER_ZERO[i] = data_get(DLD_GRP3,0,i)/rounded_ctime
    #}
  }

  printf("Ok. Done \n")
  printf("You must do dldconfig before the next acquisition \n")
  printf("to restore the normal conditions for acq.\n")

}'



#---------------------- DldScalerCalib -------------------------
##
# DldScalerCalib 
##
#%UU% dldscalercalib reference-scaler fst_scaler [lst_scaler] 
#%MDESC%
#  Allows to get the calibration factor, which is the 
#  ratio of reference scaler counts and another scaler counts.
#  The scaler range is [1,DLD_SCALERS].
#  Before this macro dldscalerassign should be done to define
#  the scaler for exposure time. Then the acq. must be performed
#  (with dldacq) to get raw scaler data in data group 3.
#  Also macro dldscalerzero should be issued once before 
#  to have background values for all scalers available.
#
def dldscalercalib '{

  local frameno;
  local eps;

  local time_value;
  local ref_scaler fst_scaler lst_scaler
  local raw_value bsub_value

  if (($#<2 ) || ($#>3)) {
    printf("Usage: dldscalercalib <ref_scaler> <fst_scaler> <lst_scaler>\n\
    \n\
    Calculation of the calibration factors for all scalers between\n\
    fst_scaler and lst_scaler. The calibration factor will\n\
    be chosen to set all values to the value of the reference scaler\n\
    (ref_scaler).\n\
    \n\
    ref_scaler : scaler to which all other scalers will be calibrated\n\
    fst_scaler : first scaler that will be calibrated \n\
    lst_scaler : last scaler that will be calibrated\n");
    exit; 
  }

  ref_scaler = $1
  fst_scaler = $2; lst_scaler = $3
  if ($# > 2) lst_scaler = $3

  printf("Calibrating scalers to a reference scaler\n");

  if ((DLD_SCALER_TIME<1) || (DLD_SCALER_TIME>DLD_SCALERS)) {
     printf("The scaler for the exposure time is not defined.\n");
     printf("It is not possible to calibrate scalers.\n");
     printf("Please define the time counter with dldscalerassing\n")
     exit
  }

  if ((ref_scaler<1) || (ref_scaler>DLD_SCALERS)) {
    printf("Reference scaler nb out of range: %d\n",ref_scaler)
    exit
  }

  if (fst_scaler < 1 ) fst_scaler = 1
  if (lst_scaler > DLD_SCALERS ) lst_scaler = DLD_SCALERS 
  if (fst_scaler > lst_scaler) {
    printf("No change\n");
    exit;
  }

  # no need to call devdldstatusget, since nb frames saved
  # in dldstart
  frameno = DLD_NO_FRAMES;
  eps=1e-32;

  # some debug printing
  printf("Scaler for exposure time = %d\n", DLD_SCALER_TIME)
  printf("Calib. fac. for time sc. = %d\n", DLD_SCALER_CALIB[DLD_SCALER_TIME-1])
  printf("Uncalibrat. counting time= %d\n", data_get(DLD_GRP3,frameno-1,DLD_SCALER_TIME-1))

  time_value = dldscalervalue(DLD_SCALER_TIME , 0.0, frameno, DLD_GRP3)
  ref_value  = dldscalervalue(ref_scaler,time_value,frameno,DLD_GRP3)
 
  printf("     reference scaler:       %d (%s)\n",ref_scaler,\
                 DLD_SCALER_NAME[ref_scaler-1])
  printf("     selected scaler range:  %d .. %d\n",\
                 fst_scaler,lst_scaler)
  printf("     counting time:          %g seconds\n",time_value);
  printf("     reference value         %g\n",ref_value);

  printf("Scaler  raw_value  bcksub_value  calib_factor\n");
  for (i=fst_scaler;i<=lst_scaler;i++) {
    # raw scaler value
    raw_value = data_get(DLD_GRP3,frameno-1,i-1)
    # counts with background subtracted 
    bsub_value = raw_value - DLD_SCALER_ZERO[i-1]*time_value 
    if (fabs(bsub_value)>eps) { 
      p "Before division"
      DLD_SCALER_CALIB[i-1] = ref_value/bsub_value; 
      printf(" %2d   %9.3g  %9.3g    %9.3g\n", i, raw_value, bsub_value, DLD_SCALER_CALIB[i-1]);
    } else { 
      printf("Scaler %d not calibrated, since no counts\n",i)
    } 
  }

}'


# ------------------------------------------------------------
#
# Here follows less used macros or macros that are never used.
#
#---------------------- DldWatch1Scaler ----------------------------
##
#  DldWatch1Scaler
##
#%UU% [scaler-nb]
#%MDESC%
#  Shows (prints on screen) the cumulated values of one scaler
#  for the number of TFG frames used in the last acquisition 
#  and that was put into data group 3 by macro scatomem.
#  If the scaler number is not given the user is prompted for one.
#  The scaler range is from 1 to DLD_SCALERS.
#  This macro is not called from any other macro and is meant
#  for the interactive use. 
#
def w1s 'dldwatch1scaler'
def dldwatch1scaler '{
  local _scaler

  if ($# > 1) {
    print "Usage: dld1scshow [scaler-no]"
    exit
  }
  
  if ($# == 1 ) {
    _scaler = $1
  } else if ($# == 0 ) {
    _scaler = getval("Scaler number(1-DLD_SCALERS)",_scaler)
  }

  if ((_scaler<1) || (_scaler>DLD_SCALERS)) {
    printf("Scaler %d out of range (1 .. DLD_SCALERS)\n",_scaler);
    exit;
  }

  #
  # Get values from data group 3 for this scaler
  #
  printf("Data for scaler %d ( %d frames)\n",_scaler,DLD_NO_FRAMES)
  printf("---------------------------- \n")
  printf("Frame    Value    \n\n")
  for(i = 0; i < DLD_NO_FRAMES; i++) {
    printf("%4d   %d\n",i+1,data_get(DLD_GRP3,i,_scaler-1)) 
  }
  # N.B. Could also use data_dump SPEC function

}'



#-----------------------------------------------------------------
#-----------------------------------------------------------------
#-- Macros here below with the names dldnew... are just to test --
#-- logic for waiting for stop for externally started run --------
#-----------------------------------------------------------------


#
#---------------------- DldNewStatus -------------------------------
##
#  DldNewStatus 
##
#%UU%
#%MDESC%
#  Shows C216 status information
#
def dldnewstatus '{
  dldstatus
}'



#---------------------- DldNewPoll -------------------------------
##
#  DldNewPoll 
##
#%UU%
#%MDESC%
#  To poll on the flag which tells when the acq. is over when 
#  started with external start.
#
def dldnewpoll '{

local waitstopforextstart 

  waitstopforextstart = 1;

  while (waitstopforextstart) {
    dldnewstatus
    sleep(0.1)
    if (DLD_STOPFOREXTSTART == 1) {
      waitstopforextstart = 0;
    }
  }

}'


#---------------------- DldNewAcq -------------------------------
##
#  DldNewAcq 
##
#%UU%
#%MDESC%
#  To do the acquisition with 1 time frame and external start.
#
def dldnewacq '{

  if ($# < 1) {
    p "Usage: dldnewacq acqtime(in seconds) [deadtime(in seconds)]"
    exit
  }
  #
  #  First configure
  #
  dldsettime  $*
  DLD_NO_CYCLES = 1
  dldnocycles
  dldconfigall "nofile"

  if (TFG_TRIG==0) {
    printf("This macro is only for ext start\n")
    exit
  }

  dldnewstart

  #sleep(1)
  # poll the state to see when the acq. is over.
  dldnewpoll
  # In the end also read scalers into the data group 3
  # Reading of scalers is done only in the end after the
  # acq. is over not to disturb the DP.
  dld_resume(1)
#  dldsave 

}'



#---------------------- DldNewStart -------------------------------
def dldnewstart '{
  local ret

  # Clear scaler group. (Re)create it.
  data_grp(DLD_GRP3,0,0)
  data_grp(DLD_GRP3,DLD_MAX_FRAME_NUMBER,DLD_SCALERS)
  DLD_GRP3_ON = 1
  dld_clear()
  startarg[0]=DLD_EXTERNAL
  startarg[1]=0 # do not clear memory since done with dld_clear()
  if ((ret = esrf_io(DLD_DEV,"Start",startarg)) == -1) {
    printf("Could not start TFU in C216 in external mode\n")
    exit
  }

}'



def opcl '{
esrf_io("id2/relay022_1/68","DevOpen")
esrf_io("id2/relay022_1/68","DevClose")
}'



# added for test only
def dldinloop '{

  dldsettime  $*
  DLD_NO_CYCLES = 1
  dldnocycles
  dldconfigall "nofile"

  while(1) {
    # start externally 
    dldstart 1
    sleep(1)
    opcl
    dldpoll
  }

}'



#-------------------------- dld_clear() ----------------------------------
def dld_clear()'{
  if (esrf_io(DLD_DEV,"InitializeMemory") == -1) {
    printf("Could not clear both memory banks in C216 \n")
    exit
  }
}'



#-------------------------- _dld_setframesforct -------------------
#%IU% 
#%MDESC%
#  Sets TFU frames, but without showing returned values
#  (to go fast in dldct) %BR%
#  Use frame info from array DLD_FRAME_ARGIN, which was prepared
#  with dldsettime macro on the basis of counting time.%BR%
#
#  Return 1 on success, 0 otherwise
def _dld_setframesforct() '{
    local ret
    ret = esrf_io(DLD_DEV,"SetTfuFrames0",DLD_FRAME_ARGIN,DLD_FRAME_INFO)
    if (ret < 0) {
        printf("Error setting frames in frame memory. Giving up\n")
        return(0)
    } else {
        DLD_NO_FRAMES = ret/2
        return(1)
    }
}'


#%IU% ()
#%MDESC%
#  Reads CUB hardware status %BR%
#  Return 1 on success, 0 otherwise
def _dld_cubstatus() '{
    local i
    if (esrf_io(DLD_DEV,"GeneralCubStatus",DLD_CUBSTATUS) < 0) {
        printf("Error getting CUB status from C216 card\n")
        return (0)
    }
    if (DLD_CUBSTATUS[6] != 1) {
        printf("At least one CUB Low-Voltage NOT OK\n")
        # show which one
        for (i = 0; i < 6; i++) {
                if (DLD_CUBSTATUS[i] != 1)
                        printf("%s is NOT OK\n", DLD_CUBLVSTRING[i])
        }
        return(0)
    }
    if (DLD_CUBSTATUS[7] != 1) {
        printf("PLL of 33MHz clock NOT OK\n")
        return(0)
    }
    return(1)
}'



#---------------------- dldcubstatus -------------------------
#%UU%
#%MDESC%
#  Reads CUB hardware status %BR%
def dldcubstatus '{
    local i
    if (_dld_cubstatus()) {
        for (i = 0; i < 6; i++) {
            printf("Low Voltage %4s = OK\n", DLD_CUBLVSTRING[i])
        }
        printf("PLL of 33MHz clock = OK\n")
        printf("CUB serial number  = %d\n", DLD_CUBSTATUS[8])
    } else {
        printf("Error getting CUB status or within CUB status\n")
    }
}'

def fson '{
if (TS_ON) {
dldsetliveout 5
} else {
dldsetliveout 1
}
}'

def fsoff '{
dldsetliveout 0
}'

def tson '{
global TS_ON
TS_ON=1
dldsetliveout 5
}'

def tsoff '
TS_ON=0
dldsetliveout 0
'


#---------------------- dld_isrunning() (user function) -------------------
#%UU%
#%MDESC% User function that returns 0 if the device is not running.
def dld_isrunning() '{
  local state_string
  local running

  state_string=esrf_io(DLD_DEV,"CompStatus","Tango::RUNNING")
  if (index(state_string,"Tango::RUNNING") != 0) running=1
  else running=0

  return( running )
}'
 


#--------------------- dld_frames (user function) -------------------------
#%UU%
#%MDESC% User function that returns the number of available frames
def dld_frames() '{
  local frames scaler_status[]
  local status 
  # read number of frames from status
  if ((status=esrf_io(DLD_DEV,"GetCompleteConfigAndStatus",scaler_status)) < 0) {
    printf("Error reading C216 status (%d)\n",status)
    exit
  }

  frames = scaler_status[14]/2

  return( frames )

}'

 

#--------------------- dld_scalers (user function) ------------------------
#%UU%
#%MDESC% User function that returns the number of available scalers 
#        of frame frameno (1,2,3,...). 
def dld_scalers( frameno ) '{
  local scalers frames
  if ( whatis("frameno")&0x08000000 ) {
    frameno=1 ; frames = 1
  } else frames = dld_frames()

  if ((0<frameno)&&(frameno<=frames)) scalers = DLD_SCALERS
  else scalers=0

  return ( scalers )
}'

 

#---------------------- dld_scalerread (user function) --------------------
#%UU%
#%MDESC% User function that reads the scalers of frame frameno 
#        from DLD_DEV and writes them to a global array with the
#        name scarr_name.
def dld_scalerread(scarr_name, frameno) '{
  local key
  local scalers i 
  local read_scalers
 
  if ( whatis("frameno")&0x08000000 ) {
    printf("dld_scalerread(\"scarr_name\",frameno)\n")
    printf("Copies the scaler values for frame frameno to a global array with\n");
    printf("the name scarr_name and returns the number of read scalers.\n")
    return(0)
  }

  scalers = dld_scalers( frameno )

# clear and preset scaler_array
  global @scarr_name[]
  for ( key in @scarr_name ) delete @scarr_name[key]
  for (i=0;i<scalers;i++) @scarr_name[i]=-1;
 
  # check state to be sure that dld is not running before reading scalers
  # in principle the dld should not run, but make a test nevertheless

  if ( dld_isrunning() ) {
    printf("\nDld: C216 is RUNNING, will be stopped before reading scalers\n")
    dldstop
  }
 
  # check it again
  if ( dld_isrunning() ) {
    printf("\nDld: C216 is RUNNING, could not be stopped. Giving up.\n")
    exit
  }

  if (scalers>0) {
    if ((read_scalers=esrf_io(DLD_DEV,"ReadScalersForOneLiveFrame",frameno-1,@scarr_name))==-1) {
      printf("Error reading scalers for frame %d\n",frameno)
      exit
    }
  } else read_scalers=0

  return ( read_scalers )

}'


 
#---------------------- dld_scalerconfig (user function)----
##
#  dld_scalerconfig 
##
#%IU% ( frarr_name, bla )
#%MDESC% Writes the frame information file to the TFU
#  Programs the TFU with the frame information file bla and reads the 
#  programmed frame array into the global array with the name frarr_name
#
def dld_scalerconfig( frarr_name, bla ) '{
  local arg_len
  local key

  if ( whatis("bla")&0x08000000 ) {
    printf("Usage: dld_scalerconfig( frarr_name, bla )\n");
    exit 
  }

  # create output array
  global @frarr_name[]
  for ( key in @frarr_name ) delete @frarr_name[key]

  arg_len=esrf_io(DLD_DEV,"SetTfuFrames0",bla,@frarr_name)

  if(arg_len==-1) {
    printf("Error setting frames in TFU. Giving up.\n")
    exit
  } else {
    # Shows TFU configuration as returned after programming TFU.
    for (i=0;i<arg_len;i+=2) {
      printf("Frame %d, dead time: %4.5g\n",(i+2)/2,@frarr_name[i])
      printf("          live time: %4.5g\n",@frarr_name[i+1])
    }
  }

}'



#%MACROS%
#%IMACROS%
#%DEPENDENCIES%
#   The macro plot2.mac has to be read before this one.
#   The macro Xdld.mac has to be read with this one.
#   The macro beamcheck.mac has to be read with this one.
#%AUTHOR% Original: Vicente Rey,
#         1996-1997: Peter Boesecke,
#         1998     : F.Sever cleanup 
#	  1999     : F.Sever modified to test with Vista device server
#	  2008     : F.Sever modified to use it with C216 device server
##%HISTORY%
# 1999-10-28 3.0.1.ID02 TN binning of displayed data, reading saved file

#%TOC%

